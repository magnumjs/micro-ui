{
  "version": 3,
  "sources": ["../lib/reactive-core.js", "../lib/outlet.js", "../lib/diffHTML.js", "../lib/bindEvents.js", "../lib/context.js", "../lib/injectSlotContent.js"],
  "sourcesContent": ["import Outlet from \"./outlet.js\";\nimport diffHTML from \"./diffHTML.js\";\nimport bindEvents from \"./bindEvents.js\";\nexport * from \"./context.js\";\nimport { context } from \"./context.js\";\nimport injectSlotContent from \"./injectSlotContent.js\";\n\nlet id = 0;\n\nexport function createComponent(\n  renderFn,\n  {\n    state: initialState = {},\n    on = {},\n    onMount,\n    onUnmount,\n    onBeforeMount,\n    onBeforeUnmount,\n    onUpdate,\n  } = {}\n) {\n  let el = null;\n  let mounted = false;\n  let props = {};\n  let prevProps = {};\n  let scheduledRenderProps = null;\n  let onBeforeMountDone = false;\n  let boundEvents = [];\n  let state = initialState;\n  let _cachedNode = null;\n  let _renderedNull = false;\n  const originalInitialState = { ...initialState };\n  let renderScheduled = false;\n  let contextUnsubs = [];\n\n  const setState = (next) => {\n    state = typeof next === \"function\" ? next(state) : { ...state, ...next };\n    if (!renderScheduled) {\n      renderScheduled = true;\n      scheduledRenderProps = { ...props };\n      queueMicrotask(() => {\n        renderScheduled = false;\n        componentFn(scheduledRenderProps);\n        scheduledRenderProps = null;\n      });\n    }\n  };\n\n  const api = {\n    refs: {},\n    setState,\n    props,\n\n    mount(targetOrSelector, initialProps = {}) {\n      if (mounted || onBeforeMountDone) return;\n\n      let target =\n        typeof targetOrSelector === \"string\"\n          ? document.querySelector(targetOrSelector)\n          : targetOrSelector;\n\n      if (!target) throw new Error(`No element matches: ${targetOrSelector}`);\n\n      const proceed = () => {\n        onBeforeMountDone = true;\n        el = target;\n\n        props = { ...props, ...initialProps };\n        prevProps = { ...props };\n        api.props = props;\n\n        componentFn(props);\n\n        // \u2705 Automatically hydrate component instances passed to props.children or props.slots\n        const slotEntries = {\n          ...(props.slots || {}),\n          children: props.children,\n        };\n\n        Object.entries(slotEntries).forEach(([key, value]) => {\n          const target = componentFn.refs[key];\n          if (!target || value == null) return;\n          injectSlotContent(target, value);\n        });\n\n        bindEvents(api, el, on, boundEvents); // \u2705 ensure this.el is hydrated before context\n\n        if (!_renderedNull) {\n          mounted = true;\n          onMount?.call(componentFn);\n          setupContextListeners();\n          // syncInstanceToAPI(api, componentFn);\n        }\n      };\n\n      runBeforeHook(onBeforeMount, proceed);\n    },\n\n    update(input = {}) {\n      if (!mounted) return;\n      const nextProps = input.props ? input.props : input;\n\n      const newOn = nextProps.on;\n      if (newOn && newOn !== on) {\n        on = newOn;\n      }\n\n      const merged = { ...props, ...nextProps };\n      prevProps = { ...props };\n      props = merged;\n      api.props = props;\n\n      componentFn(props);\n    },\n\n    render(newProps = {}) {\n      props = { ...props, ...newProps };\n      api.props = props;\n      let html =\n        typeof renderFn === \"function\"\n          ? renderFn.call(api, { state, setState, props, refs: api.refs })\n          : renderFn;\n      html = Outlet(html, props);\n\n      if (html) {\n        html = new String(html);\n        html._id = componentFn._id;\n      }\n\n      return html;\n    },\n\n    _resetInternal: () => {\n      _cachedNode = null;\n      _renderedNull = false;\n      el = null; // <-- Add this line\n      mounted = false;\n      onBeforeMountDone = false;\n      boundEvents = [];\n      props = {};\n      prevProps = {};\n      state = { ...originalInitialState };\n    },\n\n    unmount() {\n      if (!mounted || !el) return;\n\n      const cleanup = () => {\n        if (el.firstChild) {\n          _cachedNode = el.firstChild.cloneNode(true);\n          el.removeChild(el.firstChild);\n        }\n\n        boundEvents.forEach(({ node, type, listener }) => {\n          node.removeEventListener(type, listener);\n        });\n        boundEvents = [];\n\n        contextUnsubs.forEach((unsub) => unsub());\n        contextUnsubs = [];\n\n        mounted = false;\n        onBeforeMountDone = false;\n        _renderedNull = true;\n        onUnmount?.call(api);\n\n        if (api._resetInternal) api._resetInternal();\n      };\n\n      runBeforeHook(onBeforeUnmount, cleanup);\n    },\n\n    get renderFn() {\n      return renderFn;\n    },\n    get el() {\n      return el;\n    },\n    get state() {\n      return state;\n    },\n  };\n\n  api.ref = function (name) {\n    if (!this.el) return null;\n    return (\n      this.el.querySelector(`[data-ref=\"${name}\"]`) ||\n      this.el.querySelector(name) ||\n      null\n    );\n  };\n\n  api.refs = new Proxy(\n    {},\n    {\n      get(_, key) {\n        return api.ref(key);\n      },\n    }\n  );\n\n  api.action = function (e) {\n    return e.target.closest(\"[data-action]\")?.dataset.action || null;\n  };\n\n  function setupContextListeners() {\n    contextUnsubs = [];\n    Object.entries(on).forEach(([key, handler]) => {\n      if (key.includes(\"::\")) {\n        const bound = handler.bind(api);\n        const unsub = context.subscribe(key, bound);\n        contextUnsubs.push(unsub);\n      }\n    });\n  }\n\n  function render(currentProps) {\n    props = currentProps;\n    api.props = props;\n\n    const html = api.render(props);\n\n    if (html === null || html === \"\") {\n      if (!_renderedNull && el && el.firstChild) {\n        const realNode = el.firstChild;\n        _cachedNode = realNode.cloneNode(true);\n        runBeforeHook(onBeforeUnmount, () => {\n          // Remove all child nodes, not just first\n          el.innerHTML = \"\";\n          boundEvents.forEach(({ node, type, listener }) => {\n            node.removeEventListener(type, listener);\n          });\n          boundEvents = [];\n          mounted = false;\n          _renderedNull = true;\n          onUnmount?.call(api);\n          // syncInstanceToAPI(api, componentFn)\n        });\n      } else {\n        _renderedNull = true;\n      }\n      return;\n    }\n\n    if (_renderedNull && _cachedNode) {\n      el.appendChild(_cachedNode);\n      _cachedNode = null;\n      _renderedNull = false;\n      mounted = true;\n      bindEvents(api, el, on, boundEvents);\n      onMount?.call(api);\n      // syncInstanceToAPI(api, componentFn);\n      return;\n    }\n\n    _renderedNull = false;\n\n    diffHTML(el, html);\n\n    bindEvents(api, el, on, boundEvents);\n\n    if (mounted && onUpdate) {\n      onUpdate.call(api, prevProps);\n    }\n    // syncInstanceToAPI(api, componentFn);\n  }\n\n  function runBeforeHook(hook, next) {\n    if (hook) {\n      if (hook.length) hook.call(api, next);\n      else Promise.resolve(hook.call(api)).then(next);\n    } else {\n      next();\n    }\n  }\n\n  // Create the callable component function\n  function componentFn(props = {}) {\n    componentFn._render(props);\n    // syncInstanceToAPI(api, componentFn);\n    return componentFn;\n  }\n\n  // Attach API methods\n  Object.assign(componentFn, api);\n\n  // Dynamically attach instance-backed getters\n  [\"el\", \"props\", \"state\", \"setState\"].forEach((key) => {\n    Object.defineProperty(componentFn, key, {\n      get() {\n        return api[key];\n      },\n      enumerable: true,\n    });\n  });\n  componentFn._render = render;\n  componentFn.render = api.render;\n  componentFn._id = id++;\n  return componentFn;\n}\n\n// function syncInstanceToAPI(instance, componentFn) {\n//   for (const key of Object.keys(instance)) {\n//     if (!(key in componentFn)) {\n//       Object.defineProperty(componentFn, key, {\n//         get() {\n//           return instance[key];\n//         },\n//         enumerable: true,\n//       });\n//     }\n//   }\n// }\n\nexport function renderList(\n  array,\n  renderFn,\n  keyFn = (item) => item.id ?? item.key ?? item\n) {\n  return array\n    .map((item, index) => {\n      const key = keyFn(item, index);\n      const inner = renderFn(item, index);\n      // Only add data-key if inner is string and starts with a tag\n      if (typeof inner === \"string\") {\n        return inner.replace(\n          /^<([a-zA-Z0-9-]+)/,\n          `<$1 data-key=\"${String(key).replace(/\"/g, \"&quot;\")}\"`\n        );\n      }\n      return inner;\n    })\n    .join(\"\");\n}\n", "export default function Outlet(html, props = {}) {\n  if (typeof html !== \"string\") return \"\"; // return empty string if null or non-string\n\n  const { children = {}, slots = {} } = props;\n\n  function getSlotContent(name, fallback) {\n    let value;\n\n    if (!name) {\n      if (\n        children &&\n        typeof children === \"object\" &&\n        children.default != null\n      ) {\n        value = children.default;\n      } else if (slots && typeof slots === \"object\" && slots.default != null) {\n        value = slots.default;\n      } else if (typeof children === \"string\") {\n        value = children;\n      } else {\n        return fallback;\n      }\n    } else {\n      value = children?.[name] ?? slots?.[name] ?? fallback;\n    }\n\n    if (typeof value === \"function\") {\n      value = value();\n    }\n\n    if (value?.el instanceof HTMLElement) {\n      return value.el.outerHTML; // insert HTML, real DOM will be handled later\n    }\n\n    if (value instanceof Node) {\n      const temp = document.createElement(\"div\");\n      temp.appendChild(value.cloneNode(true));\n      return temp.innerHTML;\n    }\n\n    return value ?? fallback;\n  }\n\n  html = html.replace(\n    /<slot(?:\\s+name=\"([^\"]+)\")?>([\\s\\S]*?)<\\/slot>/gis,\n    (_, name, fallback) => getSlotContent(name, fallback)\n  );\n\n  html = html.replace(\n    /<([a-z]+)([^>]*)\\sdata-slot=\"([^\"]+)\"([^>]*)>([\\s\\S]*?)<\\/\\1>/gis,\n    (_, tag, before, name, after, fallback) => {\n      const content = getSlotContent(name, fallback);\n      return `<${tag}${before}${after}>${content}</${tag}>`;\n    }\n  );\n\n  return html;\n}\n", "export default function diffHTML(el, newHTML) {\n  if (!el) return false;\n\n  // Optional: parse with cache using newHTML._id\n  const temp = document.createElement(\"div\");\n  temp.innerHTML = newHTML;\n\n    // Special case: if newHTML is plain text (no elements)\n  if (temp.children.length === 0 && temp.textContent) {\n    el.textContent = temp.textContent;\n    return true;\n  }\n\n  const newChildren = Array.from(temp.children);\n  const oldChildren = Array.from(el.children);\n\n  const newKeyed = new Map();\n  const oldKeyed = new Map();\n\n  for (const child of newChildren) {\n    const key = child.dataset.key;\n    if (key) newKeyed.set(key, child);\n  }\n\n  for (const child of oldChildren) {\n    const key = child.dataset.key;\n    if (key) oldKeyed.set(key, child);\n  }\n\n  let cursor = 0;\n  for (const newChild of newChildren) {\n    const key = newChild.dataset.key;\n    let currentNode = el.children[cursor];\n\n    if (key && oldKeyed.has(key)) {\n      const existing = oldKeyed.get(key);\n\n      patchElement(existing, newChild);\n\n      if (existing !== currentNode) {\n        el.insertBefore(existing, currentNode || null);\n      }\n\n      oldKeyed.delete(key);\n    } else {\n      el.insertBefore(newChild, currentNode || null);\n    }\n\n    cursor++;\n  }\n\n  for (const leftover of oldKeyed.values()) {\n    leftover.remove();\n  }\n\n  while (el.children.length > newChildren.length) {\n    el.lastChild.remove();\n  }\n\n  return true;\n}\n\nfunction patchElement(fromEl, toEl) {\n  if (fromEl.tagName !== toEl.tagName) {\n    fromEl.replaceWith(toEl.cloneNode(true));\n    return;\n  }\n  syncAttributes(fromEl, toEl);\n  patchChildren(fromEl, toEl);\n}\n\nfunction syncAttributes(fromEl, toEl) {\n  const fromAttrs = fromEl.attributes;\n  const toAttrs = toEl.attributes;\n  for (const { name } of Array.from(fromAttrs)) {\n    if (!toEl.hasAttribute(name)) {\n      fromEl.removeAttribute(name);\n    }\n  }\n\n  for (const { name, value } of Array.from(toAttrs)) {\n    if (fromEl.getAttribute(name) !== value) {\n      fromEl.setAttribute(name, value);\n    }\n  }\n}\n\nfunction patchChildren(fromEl, toEl) {\n  const fromNodes = Array.from(fromEl.childNodes);\n  const toNodes = Array.from(toEl.childNodes);\n  const max = Math.max(fromNodes.length, toNodes.length);\n\n  for (let i = 0; i < max; i++) {\n    const fromNode = fromNodes[i];\n    const toNode = toNodes[i];\n\n    if (!toNode && fromNode) {\n      fromEl.removeChild(fromNode);\n      continue;\n    }\n\n    if (!fromNode && toNode) {\n      fromEl.appendChild(toNode.cloneNode(true));\n      continue;\n    }\n\n    patchNode(fromNode, toNode);\n  }\n}\n\nfunction patchNode(fromNode, toNode) {\n\n  if (fromNode.isEqualNode(toNode)) return;\n  if (fromNode.nodeType !== toNode.nodeType) {\n    fromNode.replaceWith(toNode.cloneNode(true));\n    return;\n  }\n\n  if (fromNode.nodeType === Node.TEXT_NODE) {\n    if (fromNode.nodeValue !== toNode.nodeValue) {\n      fromNode.nodeValue = toNode.nodeValue;\n    }\n  } else if (\n    fromNode.nodeType === Node.ELEMENT_NODE &&\n    fromNode.tagName === toNode.tagName\n  ) {\n    patchElement(fromNode, toNode);\n  } else {\n    fromNode.replaceWith(toNode.cloneNode(true));\n  }\n}\n\n", "export default function bindEvents(api, el, on, boundEvents) {\n  if (!el || !on) return;\n  const root = el.firstElementChild;\n  if (!root) return;\n\n  Object.entries(on).forEach(([key, handler]) => {\n    const isColonSyntax = key.includes(\":\");\n    const [eventType, actionOrSelector] = isColonSyntax\n      ? key.split(\":\")\n      : key.split(\" \");\n\n    const isWildcardEvent = eventType === \"*\";\n    const eventsToBind = isWildcardEvent\n      ? [\"click\", \"input\", \"change\", \"keydown\", \"submit\"]\n      : [eventType];\n\n    eventsToBind.forEach((type) => {\n      const listener = (e) => {\n        const actionTarget = e.target.closest(\"[data-action]\");\n        const actionValue = actionTarget?.dataset.action || \"\";\n        const dataArgsRaw = actionTarget?.dataset.args;\n\n        const actionParts = actionValue.split(\":\");\n        const actionName = actionParts[0];\n        let actionArgs = [];\n\n        // Prefer data-args if present\n        if (dataArgsRaw) {\n          try {\n            const parsed = JSON.parse(dataArgsRaw);\n            actionArgs = Array.isArray(parsed) ? parsed : [parsed];\n          } catch (err) {\n            console.warn(\"Invalid JSON in data-args:\", dataArgsRaw);\n          }\n        } else {\n          actionArgs = actionParts.slice(1);\n        }\n\n        const context = {\n          event: e,\n          state: api.state,\n          setState: api.setState,\n          props: api.props,\n          refs: api.refs,\n          action: actionName,\n          args: actionArgs,\n        };\n\n        // Action handler\n        if (isColonSyntax && actionTarget) {\n          const matches =\n            (actionOrSelector === \"*\" || actionOrSelector === actionName) &&\n            (isWildcardEvent || e.type === eventType);\n\n          if (matches) {\n            return handler.call(api, context);\n          }\n        }\n\n        // Fallback to selector-based if no action match\n        if (!isColonSyntax) {\n          const target = e.target.closest(actionOrSelector || \"*\");\n          if (target && root.contains(target)) {\n            return handler.call(api, context);\n          }\n        }\n      };\n\n      const marker = `__microBound_${type}_${key}`;\n      if (!root[marker]) {\n        root.addEventListener(type, listener);\n        root[marker] = true;\n        boundEvents.push({ node: root, type, listener });\n      }\n    });\n  });\n}\n", "export function createState(initial) {\n  let state = initial;\n  const subs = new Set();\n\n  function setState(next) {\n    state = typeof next === \"function\" ? next(state) : { ...state, ...next };\n    subs.forEach((fn) => fn(state));\n  }\n\n  function subscribe(fn) {\n    subs.add(fn);\n    fn(state);\n    return () => subs.delete(fn);\n  }\n\n  function get() {\n    return state;\n  }\n\n  return { get, setState, getState: get, subscribe };\n}\n// Top-level shared pub/sub\nconst channels = new Map();\n\nexport const context = {\n  subscribe(eventName, fn) {\n    if (!channels.has(eventName)) {\n      channels.set(eventName, new Set());\n    }\n    const set = channels.get(eventName);\n    set.add(fn);\n    return () => set.delete(fn);\n  },\n\n  emit(eventName, payload) {\n    const set = channels.get(eventName);\n    if (set) {\n      for (const fn of set) fn(payload);\n    }\n  },\n\n  clear() {\n    channels.clear(); // Optional: useful for testing or full reset\n  },\n};\n\nconst stores = new Map();\n\nexport function shared(key, initial = {}) {\n  if (!stores.has(key)) {\n    const state = createState(initial);\n    const api = {\n      ...state,\n      emit(event, payload) {\n        state.setState(payload);\n        context.emit(`${key}::${event}`, state.getState());\n      },\n      on(event, fn) {\n        return context.subscribe(`${key}::${event}`, fn);\n      },\n    };\n    stores.set(key, api);\n  }\n\n  return stores.get(key);\n}\nshared.clear = () => stores.clear();\n\n", "// injectSlotContent.js\n\nexport default function injectSlotContent(refNode, value) {\n  if (!refNode || value == null) return;\n\n  const resolved = typeof value === \"function\" ? value() : value;\n\n  // Array of items\n  if (Array.isArray(resolved)) {\n    const fragment = document.createDocumentFragment();\n\n    resolved.forEach((origItem) => {\n      let item = typeof origItem === \"function\" ? origItem() : origItem;\n      if (item && typeof item.mount === \"function\") {\n        const temp = document.createElement(\"div\");\n        item.mount(temp);\n        if (temp.firstElementChild) {\n          fragment.appendChild(temp.firstElementChild);\n        }\n      } else if (item?.el instanceof HTMLElement) {\n        fragment.appendChild(item.el);\n      } else if (item instanceof Node) {\n        fragment.appendChild(item);\n      } else if (typeof item === \"string\") {\n        const temp = document.createElement(\"div\");\n        temp.innerHTML = item;\n        if (temp.firstElementChild) {\n          fragment.appendChild(temp.firstElementChild);\n        }\n      }\n    });\n\n    refNode.replaceWith(fragment);\n    return;\n  }\n\n  // Single item logic\n  if (resolved && typeof resolved.mount === \"function\") {\n    const temp = document.createElement(\"div\");\n    refNode.replaceWith(temp);\n    resolved.mount(temp);\n  } else if (resolved?.el instanceof HTMLElement) {\n    refNode.replaceWith(resolved.el);\n  } else if (resolved instanceof Node) {\n    refNode.replaceWith(resolved);\n  } else if (typeof resolved === \"string\") {\n    const temp = document.createElement(\"div\");\n    temp.innerHTML = resolved;\n    if (temp.firstElementChild) {\n      refNode.replaceWith(temp.firstElementChild);\n    }\n  } else {\n    refNode.replaceWith(document.createTextNode(\"\"));\n  }\n}\n"],
  "mappings": "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",
  "names": ["reactive_core_exports", "__export", "context", "createComponent", "createState", "renderList", "shared", "Outlet", "html", "props", "children", "slots", "getSlotContent", "name", "fallback", "value", "temp", "_", "tag", "before", "after", "content", "diffHTML", "el", "newHTML", "temp", "newChildren", "oldChildren", "newKeyed", "oldKeyed", "child", "key", "cursor", "newChild", "currentNode", "existing", "patchElement", "leftover", "fromEl", "toEl", "syncAttributes", "patchChildren", "fromAttrs", "toAttrs", "name", "value", "fromNodes", "toNodes", "max", "fromNode", "toNode", "patchNode", "bindEvents", "api", "el", "on", "boundEvents", "root", "key", "handler", "isColonSyntax", "eventType", "actionOrSelector", "isWildcardEvent", "type", "listener", "e", "actionTarget", "actionValue", "dataArgsRaw", "actionParts", "actionName", "actionArgs", "parsed", "context", "target", "marker", "createState", "initial", "state", "subs", "setState", "next", "fn", "subscribe", "get", "channels", "context", "eventName", "set", "payload", "stores", "shared", "key", "api", "event", "injectSlotContent", "refNode", "value", "resolved", "fragment", "origItem", "item", "temp", "id", "createComponent", "renderFn", "initialState", "on", "onMount", "onUnmount", "onBeforeMount", "onBeforeUnmount", "onUpdate", "el", "mounted", "props", "prevProps", "scheduledRenderProps", "onBeforeMountDone", "boundEvents", "state", "_cachedNode", "_renderedNull", "originalInitialState", "renderScheduled", "contextUnsubs", "setState", "next", "componentFn", "api", "targetOrSelector", "initialProps", "target", "runBeforeHook", "slotEntries", "key", "value", "injectSlotContent", "bindEvents", "setupContextListeners", "input", "nextProps", "newOn", "merged", "newProps", "html", "Outlet", "node", "type", "listener", "unsub", "name", "_", "e", "handler", "bound", "context", "render", "currentProps", "diffHTML", "hook", "renderList", "array", "keyFn", "item", "index", "inner"]
}
