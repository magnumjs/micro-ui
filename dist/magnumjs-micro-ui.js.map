{
  "version": 3,
  "sources": ["../lib/reactive-core.js", "../lib/diffHTML.js", "../lib/bindEvents.js", "../lib/context.js", "../lib/get-refs.js", "../lib/injectSlotContent.js", "../lib/hydrateSlots.js"],
  "sourcesContent": ["import diffHTML from \"./diffHTML.js\";\r\nimport bindEvents from \"./bindEvents.js\";\r\nexport * from \"./context.js\";\r\nimport { context } from \"./context.js\";\r\nimport getRef from \"./get-refs.js\";\r\nimport hydrateSlots from \"./hydrateSlots.js\";\r\nlet id = 1;\r\n\r\nexport const __VERSION__ = process.env.APP_VERSION || \"\";\r\n\r\nfunction syncInstanceToAPI(instance, componentFn) {\r\n  for (const key of Object.keys(instance)) {\r\n    if (!(key in componentFn)) {\r\n      Object.defineProperty(componentFn, key, {\r\n        get() {\r\n          return instance[key];\r\n        },\r\n        enumerable: true,\r\n      });\r\n    }\r\n  }\r\n}\r\n\r\nlet currentComponent = null;\r\n\r\nexport function createComponent(arg1, arg2 = {}) {\r\n  let renderFn;\r\n  let options = {};\r\n\r\n  const ftype = typeof arg1;\r\n  // Detect object-style usage\r\n  if (\r\n    ftype === \"object\" &&\r\n    ftype !== \"funcion\" &&\r\n    arg1 !== null &&\r\n    !Array.isArray(arg1)\r\n  ) {\r\n    renderFn = arg1.render;\r\n    options = { ...arg1 };\r\n    delete options.render; // avoid duplicate\r\n  } else {\r\n    // Old signature: createComponent(renderFn, options)\r\n    renderFn = arg1;\r\n    options = arg2 || {};\r\n  }\r\n\r\n  let {\r\n    state: initialState = {},\r\n    on = {},\r\n    slots = {},\r\n    onMount,\r\n    onUnmount,\r\n    onBeforeMount,\r\n    onBeforeUnmount,\r\n    onUpdate,\r\n  } = options;\r\n\r\n  let el = null;\r\n  let mounted = false;\r\n  let props = {};\r\n  let prevProps = {};\r\n  let scheduledRenderProps = null;\r\n  let onBeforeMountDone = false;\r\n  let boundEvents = [];\r\n  let state = initialState;\r\n  let _cachedNode = null;\r\n  let _renderedNull = false;\r\n  const originalInitialState = { ...initialState };\r\n  let renderScheduled = false;\r\n  let contextUnsubs = [];\r\n\r\n  const setState = (next) => {\r\n    state = typeof next === \"function\" ? next(state) : { ...state, ...next };\r\n    if (!renderScheduled) {\r\n      renderScheduled = true;\r\n      scheduledRenderProps = { ...props };\r\n      queueMicrotask(() => {\r\n        renderScheduled = false;\r\n        componentFn(scheduledRenderProps);\r\n        scheduledRenderProps = null;\r\n      });\r\n    }\r\n  };\r\n\r\n  const api = {\r\n    refs: {},\r\n    setState,\r\n    props,\r\n    isMounted: () => mounted,\r\n    _mountedChildren: [],\r\n\r\n    mount(targetOrSelector, initialProps = {}) {\r\n      if (mounted || onBeforeMountDone) {\r\n        //  console.log(\"Component already mounted or mounting in progress\", componentFn._id);\r\n        return;\r\n      }\r\n      let target =\r\n        typeof targetOrSelector === \"string\"\r\n          ? document.querySelector(targetOrSelector)\r\n          : targetOrSelector;\r\n\r\n      if (!target) throw new Error(`No element matches: ${targetOrSelector}`);\r\n\r\n      const proceed = () => {\r\n        onBeforeMountDone = true;\r\n        el = target;\r\n        // console.log(\"Mounting component\", componentFn._id, el);\r\n        // Mark this as a component root for event isolation\r\n        el.setAttribute(\"data-comp-root\", componentFn._id);\r\n\r\n        props = { ...props, ...initialProps };\r\n        prevProps = { ...props };\r\n        api.props = props;\r\n\r\n        componentFn(props);\r\n\r\n        // \u2705 Automatically hydrate component instances passed to props.children or props.slots\r\n        // hydrateSlots(componentFn, props, api, slots);\r\n\r\n        // bindEvents(api, el, on, boundEvents); // \u2705 ensure this.el is hydrated before context\r\n\r\n        if (!_renderedNull) {\r\n          mounted = true;\r\n          onMount?.call(componentFn);\r\n          setupContextListeners();\r\n        }\r\n      };\r\n\r\n      runBeforeHook(onBeforeMount, proceed);\r\n    },\r\n\r\n    update(input = {}) {\r\n      if (!mounted) return;\r\n      const nextProps = input.props ? input.props : input;\r\n\r\n      const newOn = nextProps.on;\r\n      if (newOn && newOn !== on) {\r\n        on = newOn;\r\n      }\r\n\r\n      const merged = { ...props, ...nextProps };\r\n      prevProps = { ...props };\r\n      props = merged;\r\n      api.props = props;\r\n\r\n      componentFn(props);\r\n    },\r\n\r\n    render(newProps = {}) {\r\n      props = { ...props, ...newProps };\r\n      api.props = props;\r\n      let html =\r\n        typeof renderFn === \"function\"\r\n          ? renderFn.call(api, { state, setState, props, refs: api.refs })\r\n          : renderFn;\r\n\r\n      if (html) {\r\n        html = new String(html);\r\n        html._id = componentFn._id;\r\n      }\r\n\r\n      syncInstanceToAPI(api, componentFn);\r\n      return html;\r\n    },\r\n\r\n    _resetInternal: () => {\r\n      api._mountedChildren.forEach((child) => {\r\n        if (child && typeof child.unmount === \"function\") {\r\n          child.unmount();\r\n        }\r\n      });\r\n      api._mountedChildren = [];\r\n      _cachedNode = null;\r\n      _renderedNull = false;\r\n      el = null; // <-- Add this line\r\n      mounted = false;\r\n      onBeforeMountDone = false;\r\n      boundEvents = [];\r\n      props = {};\r\n      prevProps = {};\r\n      state = { ...originalInitialState };\r\n    },\r\n\r\n    unmount() {\r\n      if (!mounted || !el) return;\r\n\r\n      const cleanup = () => {\r\n        if (el.firstChild) {\r\n          _cachedNode = el.firstChild.cloneNode(true);\r\n          el.removeChild(el.firstChild);\r\n        }\r\n\r\n        boundEvents.forEach(({ node, type, listener }) => {\r\n          node.removeEventListener(type, listener);\r\n        });\r\n        boundEvents = [];\r\n\r\n        contextUnsubs.forEach((unsub) => unsub());\r\n        contextUnsubs = [];\r\n\r\n        mounted = false;\r\n        onBeforeMountDone = false;\r\n        _renderedNull = true;\r\n        onUnmount?.call(api);\r\n\r\n        if (api._resetInternal) api._resetInternal();\r\n      };\r\n\r\n      runBeforeHook(onBeforeUnmount, cleanup);\r\n    },\r\n\r\n    get renderFn() {\r\n      return renderFn;\r\n    },\r\n    get el() {\r\n      return el;\r\n    },\r\n    get state() {\r\n      return state;\r\n    },\r\n  };\r\n\r\n  api.ref = function (name) {\r\n    return getRef(this.el, name);\r\n  };\r\n\r\n  api.refs = new Proxy(\r\n    {},\r\n    {\r\n      get(_, key) {\r\n        return api.ref(key);\r\n      },\r\n    }\r\n  );\r\n\r\n  api.action = function (e) {\r\n    return e.target.closest(\"[data-action]\")?.dataset.action || null;\r\n  };\r\n\r\n  function setupContextListeners() {\r\n    contextUnsubs = [];\r\n    Object.entries(on).forEach(([key, handler]) => {\r\n      if (key.includes(\"::\")) {\r\n        const bound = handler.bind(api);\r\n        const unsub = context.subscribe(key, bound);\r\n        contextUnsubs.push(unsub);\r\n      }\r\n    });\r\n  }\r\n\r\n  function render(currentProps) {\r\n    props = { ...api.props, ...currentProps };\r\n    api.props = props;\r\n\r\n    if (!el || el.isConnected === false) {\r\n      //console.warn(\"Component root element is not connected to the DOM, skipping render:\", componentFn._id, componentFn.renderFn())\r\n      //return;\r\n    }\r\n\r\n    const html = api.render(props);\r\n\r\n    if (html === null || html === \"\") {\r\n      if (!_renderedNull && el && el.firstChild) {\r\n        const realNode = el.firstChild;\r\n        _cachedNode = realNode.cloneNode(true);\r\n        runBeforeHook(onBeforeUnmount, () => {\r\n          // Remove all child nodes, not just first\r\n          el.innerHTML = \"\";\r\n          boundEvents.forEach(({ node, type, listener }) => {\r\n            node.removeEventListener(type, listener);\r\n          });\r\n          boundEvents = [];\r\n          mounted = false;\r\n          _renderedNull = true;\r\n          onUnmount?.call(api);\r\n        });\r\n      } else {\r\n        _renderedNull = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (_renderedNull && _cachedNode) {\r\n      el.appendChild(_cachedNode);\r\n      _cachedNode = null;\r\n      _renderedNull = false;\r\n      mounted = true;\r\n      bindEvents(api, el, on, boundEvents);\r\n      onMount?.call(api);\r\n      return;\r\n    }\r\n\r\n    diffHTML(el, html);\r\n    hydrateSlots(componentFn, props, api, slots);\r\n\r\n    //    console.log(\"Rendered HTML:\", html, el === null ? \"null\" : el.outerHTML, el === componentFn.el, el.isConnected)\r\n\r\n    bindEvents(api, el, on, boundEvents);\r\n\r\n    if (mounted && onUpdate) {\r\n      onUpdate.call(api, prevProps);\r\n    }\r\n    _renderedNull = false;\r\n    return html;\r\n  }\r\n\r\n  function runBeforeHook(hook, next) {\r\n    if (hook) {\r\n      if (hook.length) hook.call(api, next);\r\n      else Promise.resolve(hook.call(api)).then(next);\r\n    } else {\r\n      next();\r\n    }\r\n  }\r\n\r\n  let lastHtml = \"\";\r\n  // Create the callable component function\r\n  function componentFn(props = {}) {\r\n    currentComponent = componentFn;\r\n    lastHtml = componentFn._render(props);\r\n    currentComponent = null;\r\n    return componentFn;\r\n  }\r\n\r\n  // Add toString method to componentFn\r\n\r\n  componentFn.toString = function () {\r\n    return lastHtml ? String(lastHtml) : \"\";\r\n  };\r\n\r\n  // Attach API methods\r\n  Object.assign(componentFn, api);\r\n\r\n  // Dynamically attach instance-backed getters\r\n  [\"el\", \"props\", \"state\", \"setState\"].forEach((key) => {\r\n    Object.defineProperty(componentFn, key, {\r\n      get() {\r\n        return api[key];\r\n      },\r\n      enumerable: true,\r\n      configurable: false,\r\n    });\r\n  });\r\n\r\n  componentFn._render = render;\r\n  componentFn.render = api.render;\r\n  componentFn._id = id++;\r\n\r\n  return componentFn;\r\n}\r\n\r\nexport function renderList(\r\n  array,\r\n  renderFn,\r\n  keyFn = (item) => item.id ?? item.key ?? item\r\n) {\r\n  return array\r\n    .map((item, index) => {\r\n      const key = keyFn(item, index);\r\n      const inner = renderFn(item, index);\r\n      // Only add data-key if inner is string and starts with a tag\r\n      if (typeof inner === \"string\") {\r\n        return inner.replace(\r\n          /^<([a-zA-Z0-9-]+)/,\r\n          `<$1 data-key=\"${String(key).replace(/\"/g, \"&quot;\")}\"`\r\n        );\r\n      }\r\n      return inner;\r\n    })\r\n    .join(\"\");\r\n}\r\n\r\n// Usage in composables:\r\nexport function useCurrentComponent() {\r\n  return currentComponent;\r\n}\r\n", "export default function diffHTML(el, newHTML) {\r\n  if (!el) return false;\r\n\r\n  // Optional: parse with cache using newHTML._id\r\n  const temp = document.createElement(\"div\");\r\n  temp.innerHTML = newHTML;\r\n\r\n  // Special case: if newHTML is plain text (no elements)\r\n  if (temp.children.length === 0 && temp.textContent) {\r\n    el.textContent = temp.textContent;\r\n    return true;\r\n  }\r\n\r\n  const newChildren = Array.from(temp.children);\r\n  const oldChildren = Array.from(el.children);\r\n\r\n  const newKeyed = new Map();\r\n  const oldKeyed = new Map();\r\n\r\n  for (const child of newChildren) {\r\n    const key = child.dataset.key;\r\n    if (key) newKeyed.set(key, child);\r\n  }\r\n\r\n  for (const child of oldChildren) {\r\n    const key = child.dataset.key;\r\n    if (key) oldKeyed.set(key, child);\r\n  }\r\n\r\n  let cursor = 0;\r\n  for (const newChild of newChildren) {\r\n    const key = newChild.dataset.key;\r\n    let currentNode = el.children[cursor];\r\n\r\n    if (key && oldKeyed.has(key)) {\r\n      const existing = oldKeyed.get(key);\r\n\r\n      patchElement(existing, newChild);\r\n\r\n      if (existing !== currentNode) {\r\n        el.insertBefore(existing, currentNode || null);\r\n      }\r\n\r\n      oldKeyed.delete(key);\r\n    } else {\r\n      el.insertBefore(newChild, currentNode || null);\r\n    }\r\n\r\n    cursor++;\r\n  }\r\n\r\n  for (const leftover of oldKeyed.values()) {\r\n    leftover.remove();\r\n  }\r\n\r\n  while (el.children.length > newChildren.length) {\r\n    el.lastChild.remove();\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction patchElement(fromEl, toEl) {\r\n  if (fromEl.tagName !== toEl.tagName) {\r\n    fromEl.replaceWith(toEl.cloneNode(true));\r\n    return;\r\n  }\r\n  syncAttributes(fromEl, toEl);\r\n  patchChildren(fromEl, toEl);\r\n}\r\n\r\nfunction syncAttributes(fromEl, toEl) {\r\n  const fromAttrs = fromEl.attributes;\r\n  const toAttrs = toEl.attributes;\r\n  for (const { name } of Array.from(fromAttrs)) {\r\n    if (!toEl.hasAttribute(name)) {\r\n      fromEl.removeAttribute(name);\r\n    }\r\n  }\r\n\r\n  for (const { name, value } of Array.from(toAttrs)) {\r\n    if (fromEl.getAttribute(name) !== value) {\r\n      fromEl.setAttribute(name, value);\r\n    }\r\n  }\r\n}\r\n\r\nfunction patchChildren(fromEl, toEl) {\r\n  const fromNodes = Array.from(fromEl.childNodes);\r\n  const toNodes = Array.from(toEl.childNodes);\r\n  const max = Math.max(fromNodes.length, toNodes.length);\r\n\r\n  for (let i = 0; i < max; i++) {\r\n    const fromNode = fromNodes[i];\r\n    const toNode = toNodes[i];\r\n\r\n    if (!toNode && fromNode) {\r\n      fromEl.removeChild(fromNode);\r\n      continue;\r\n    }\r\n\r\n    if (!fromNode && toNode) {\r\n      fromEl.appendChild(toNode.cloneNode(true));\r\n      continue;\r\n    }\r\n\r\n    patchNode(fromNode, toNode);\r\n  }\r\n}\r\n\r\nfunction patchNode(fromNode, toNode) {\r\n  if (fromNode.isEqualNode(toNode)) return;\r\n  if (fromNode.nodeType !== toNode.nodeType) {\r\n    fromNode.replaceWith(toNode.cloneNode(true));\r\n    return;\r\n  }\r\n\r\n  if (fromNode.nodeType === Node.TEXT_NODE) {\r\n    if (fromNode.nodeValue !== toNode.nodeValue) {\r\n      fromNode.nodeValue = toNode.nodeValue;\r\n    }\r\n  } else if (\r\n    fromNode.nodeType === Node.ELEMENT_NODE &&\r\n    fromNode.tagName === toNode.tagName\r\n  ) {\r\n    patchElement(fromNode, toNode);\r\n  } else {\r\n    fromNode.replaceWith(toNode.cloneNode(true));\r\n  }\r\n}\r\n", "export default function bindEvents(api, el, on, boundEvents) {\r\n  if (!el || !on) return;\r\n  const root = el.firstElementChild;\r\n  if (!root) return;\r\n\r\n  function traverse(node, isRoot = false) {\r\n    if (!node) return;\r\n    // Stop at component boundaries, except for the root node itself\r\n    if (!isRoot && node.hasAttribute && node.hasAttribute(\"data-comp-root\")) {\r\n      //return;\r\n    }\r\n\r\n    Object.entries(on).forEach(([key, handler]) => {\r\n      const isColonSyntax = key.includes(\":\");\r\n      const [eventType, actionOrSelector] = isColonSyntax\r\n        ? key.split(\":\")\r\n        : key.split(\" \");\r\n\r\n      const isWildcardEvent = eventType === \"*\";\r\n      const eventsToBind = isWildcardEvent\r\n        ? [\"click\", \"input\", \"change\", \"keydown\", \"submit\"]\r\n        : [eventType];\r\n\r\n      eventsToBind.forEach((type) => {\r\n        const listener = (e) => {\r\n          const actionTarget = e.target.closest(\"[data-action]\");\r\n          const actionValue = actionTarget?.dataset.action || \"\";\r\n          const dataArgsRaw = actionTarget?.dataset.args;\r\n\r\n          const actionParts = actionValue.split(\":\");\r\n          const actionName = actionParts[0];\r\n          let actionArgs = [];\r\n\r\n          // Prefer data-args if present\r\n          if (dataArgsRaw) {\r\n            try {\r\n              const parsed = JSON.parse(dataArgsRaw);\r\n              actionArgs = Array.isArray(parsed) ? parsed : [parsed];\r\n            } catch (err) {\r\n              console.warn(\"Invalid JSON in data-args:\", dataArgsRaw);\r\n            }\r\n          } else {\r\n            actionArgs = actionParts.slice(1);\r\n          }\r\n\r\n          const context = {\r\n            event: e,\r\n            state: api.state,\r\n            setState: api.setState,\r\n            props: api.props,\r\n            refs: api.refs,\r\n            action: actionName,\r\n            args: actionArgs,\r\n          };\r\n\r\n          // Action handler\r\n          if (isColonSyntax && actionTarget) {\r\n            const matches =\r\n              (actionOrSelector === \"*\" || actionOrSelector === actionName) &&\r\n              (isWildcardEvent || e.type === eventType);\r\n\r\n            if (matches) {\r\n              return handler.call(api, context);\r\n            }\r\n          }\r\n\r\n          // Fallback to selector-based if no action match\r\n          if (!isColonSyntax) {\r\n            const target = e.target.closest(actionOrSelector || \"*\");\r\n            if (target && root.contains(target)) {\r\n              return handler.call(api, context);\r\n            }\r\n          }\r\n        };\r\n\r\n        const marker = `__microBound_${type}_${key}`;\r\n        if (!root[marker]) {\r\n          root.addEventListener(type, listener);\r\n          root[marker] = true;\r\n          boundEvents.push({ node: root, type, listener });\r\n        }\r\n      });\r\n    });\r\n\r\n    for (const child of node.children) {\r\n      traverse(child, false);\r\n    }\r\n  }\r\n  traverse(el, true);\r\n}\r\n", "export function createState(initial) {\r\n  let state = initial;\r\n  const subs = new Set();\r\n\r\n  function setState(next) {\r\n    state = typeof next === \"function\" ? next(state) : { ...state, ...next };\r\n    subs.forEach((fn) => fn(state));\r\n  }\r\n\r\n  function subscribe(fn) {\r\n    subs.add(fn);\r\n    fn(state);\r\n    return () => subs.delete(fn);\r\n  }\r\n\r\n  function get() {\r\n    return state;\r\n  }\r\n\r\n  return { get, setState, getState: get, subscribe };\r\n}\r\n// Top-level shared pub/sub\r\nconst channels = new Map();\r\n\r\nexport const context = {\r\n  subscribe(eventName, fn) {\r\n    if (!channels.has(eventName)) {\r\n      channels.set(eventName, new Set());\r\n    }\r\n    const set = channels.get(eventName);\r\n    set.add(fn);\r\n    return () => set.delete(fn);\r\n  },\r\n\r\n  emit(eventName, payload) {\r\n    const set = channels.get(eventName);\r\n    if (set) {\r\n      for (const fn of set) fn(payload);\r\n    }\r\n  },\r\n\r\n  clear() {\r\n    channels.clear(); // Optional: useful for testing or full reset\r\n  },\r\n};\r\n\r\nconst stores = new Map();\r\n\r\nexport function shared(key, initial = {}) {\r\n  if (!stores.has(key)) {\r\n    const state = createState(initial);\r\n    const api = {\r\n      ...state,\r\n      emit(event, payload) {\r\n        state.setState(payload);\r\n        context.emit(`${key}::${event}`, state.getState());\r\n      },\r\n      on(event, fn) {\r\n        return context.subscribe(`${key}::${event}`, fn);\r\n      },\r\n    };\r\n    stores.set(key, api);\r\n  }\r\n\r\n  return stores.get(key);\r\n}\r\nshared.clear = () => stores.clear();\r\n", "const refCache = {}; // Global cache for storing references\r\n\r\nexport default function ref(el, name) {\r\n  if (!el) return null;\r\n\r\n  // 1. Check the cache first\r\n  if (refCache[name]) {\r\n    const cachedElement = refCache[name];\r\n\r\n    // Check if the cached element is still connected to the DOM\r\n    if (cachedElement.isConnected) {\r\n      // Also ensure it's within the current scope (this.el or its parent)\r\n      if (\r\n        el.contains(cachedElement) ||\r\n        (el.parentNode &&\r\n          el.parentNode !== document.body &&\r\n          el.parentNode.contains(cachedElement))\r\n      ) {\r\n        return cachedElement;\r\n      } else {\r\n        // If it's connected but not in the desired scope, it's stale for this context\r\n        delete refCache[name]; // Remove from cache\r\n      }\r\n    } else {\r\n      // Element is no longer connected to the DOM, dispose of it\r\n      delete refCache[name];\r\n    }\r\n  }\r\n\r\n  // 2. If not found in cache or disposed, perform the search\r\n  // Prioritize ID lookup as it's typically the fastest\r\n  const elementById = document.getElementById(name);\r\n  if (\r\n    elementById &&\r\n    (el.contains(elementById) ||\r\n      (el.parentNode && el.parentNode.contains(elementById)))\r\n  ) {\r\n    refCache[name] = elementById; // Cache the found element\r\n    return elementById;\r\n  }\r\n\r\n  // Attempt each query on both this.el and its parent\r\n  const selectors = [\r\n    `[data-ref=\"${name}\"]`,\r\n    `[data-slot=\"${name}\"]`,\r\n    `slot[name=\"${name}\"]`,\r\n    `slot:not([name])`,\r\n    name, // General selector, less performant if broad\r\n  ];\r\n\r\n  for (const selector of selectors) {\r\n    let foundElement = el.querySelector(selector);\r\n    if (foundElement) {\r\n      refCache[name] = foundElement; // Cache the found element\r\n      return foundElement;\r\n    }\r\n\r\n    // Check parentNode if not found in this.el\r\n    if (el.parentNode) {\r\n      foundElement = el.parentNode.querySelector(selector);\r\n      if (foundElement) {\r\n        refCache[name] = foundElement; // Cache the found element\r\n        return foundElement;\r\n      }\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n", "// injectSlotContent.js\r\nconst slotContentCache = new WeakMap();\r\n\r\nexport default function injectSlotContent(refNode, value, api) {\r\n  // Remove previous injected content if slot is null/undefined\r\n  if (!refNode || value === null) {\r\n    return;\r\n  }\r\n\r\n  // Use refNode as cache key\r\n  if (slotContentCache.has(refNode)) {\r\n    const cached = slotContentCache.get(refNode);\r\n    if (cached.value === value) {\r\n      // Already injected, skip\r\n      return;\r\n    }\r\n  }\r\n\r\n  let resolved = typeof value === \"function\" ? value() : value;\r\n\r\n  // Unwrap { default: ... } for default slot\r\n  if (\r\n    refNode.nodeName === \"SLOT\" &&\r\n    !refNode.hasAttribute(\"name\") &&\r\n    resolved &&\r\n    typeof resolved === \"object\" &&\r\n    \"default\" in resolved\r\n  ) {\r\n    resolved = resolved.default;\r\n  }\r\n  // Array of items\r\n  if (Array.isArray(resolved)) {\r\n    const fragment = document.createDocumentFragment();\r\n\r\n    resolved.forEach((origItem) => {\r\n      let item = typeof origItem === \"function\" ? origItem() : origItem;\r\n      if (item && typeof item.mount === \"function\") {\r\n        const temp = document.createElement(\"div\");\r\n        if (item.isMounted()) {\r\n          item.update();\r\n          if (item.el instanceof HTMLElement) {\r\n            fragment.appendChild(item.el);\r\n          }\r\n        } else {\r\n          item.mount(temp);\r\n          if (!api._mountedChildren.includes(item)) {\r\n            api._mountedChildren.push(item);\r\n          }\r\n          // Append all children of temp, not just the first\r\n          while (temp.firstChild) {\r\n            fragment.appendChild(temp.firstChild);\r\n          }\r\n        }\r\n      } else if (item?.el instanceof HTMLElement) {\r\n        fragment.appendChild(item.el);\r\n      } else if (item instanceof Node) {\r\n        fragment.appendChild(item);\r\n      } else if (typeof item === \"string\") {\r\n        const temp = document.createElement(\"div\");\r\n        temp.innerHTML = item;\r\n        while (temp.firstChild) {\r\n          fragment.appendChild(temp.firstChild);\r\n        }\r\n      }\r\n    });\r\n\r\n    refNode.replaceWith(fragment);\r\n    slotContentCache.set(refNode, { value });\r\n    return;\r\n  }\r\n\r\n  // Single item logic\r\n  if (resolved && typeof resolved.mount === \"function\") {\r\n    if (resolved.isMounted()) {\r\n      // Reuse instead of remount\r\n      resolved.update();\r\n      // Ensure DOM position is correct\r\n      if (resolved.el !== refNode) {\r\n        refNode.replaceWith(resolved.el);\r\n      }\r\n    } else {\r\n      // First mount\r\n      const temp = document.createElement(\"div\");\r\n      refNode.replaceWith(temp);\r\n      resolved.mount(temp);\r\n      if (resolved.el === refNode) {\r\n        resolved.el = temp;\r\n      }\r\n    }\r\n    if (!api._mountedChildren.includes(resolved)) {\r\n      api._mountedChildren.push(resolved);\r\n    }\r\n  } else if (resolved?.el instanceof HTMLElement) {\r\n    refNode.replaceWith(resolved.el);\r\n  } else if (resolved instanceof Node) {\r\n    refNode.replaceWith(resolved);\r\n  } else if (typeof resolved === \"string\") {\r\n    // Replace slot with HTML nodes (not just text)\r\n    const temp = document.createElement(\"div\");\r\n    temp.innerHTML = resolved;\r\n    // Insert all children, not just the first\r\n    const fragment = document.createDocumentFragment();\r\n    while (temp.firstChild) {\r\n      fragment.appendChild(temp.firstChild);\r\n    }\r\n    refNode.replaceWith(fragment);\r\n  } else {\r\n    refNode.replaceWith(document.createTextNode(\"\"));\r\n  }\r\n  // After replacing slot content, cache the value\r\n\r\n  slotContentCache.set(refNode, { value });\r\n}\r\n", "import getRef from \"./get-refs\";\r\nimport injectSlotContent from \"./injectSlotContent\";\r\n\r\nexport default function hydrateSlots(componentFn, props, api, initialSlots) {\r\n  // Resolve initial slots (can be object or function)\r\n  let dynamicSlots =\r\n    typeof initialSlots === \"function\"\r\n      ? initialSlots.call(api, props)\r\n      : typeof initialSlots === \"object\"\r\n      ? initialSlots\r\n      : {};\r\n\r\n  // Merge with props.slots\r\n  let slotEntries = { ...dynamicSlots, ...(props.slots || {}) };\r\n\r\n  // If slots is a component or array, treat as default\r\n  if (\r\n    typeof props.slots === \"function\" ||\r\n    Array.isArray(props.slots)\r\n    // ||    (props.slots && typeof props.slots === \"object\" && !(\"default\" in props.slots))\r\n  ) {\r\n    slotEntries = { default: props.slots };\r\n  }\r\n\r\n  // Default slot fallback\r\n  if (props.children !== undefined) {\r\n    slotEntries.default = props.children;\r\n  } else if (!slotEntries.default) {\r\n    slotEntries.default = null;\r\n  }\r\n\r\n  // console.log(\"hydrateSlots\", slotEntries, componentFn._id);\r\n  // Inject slot content\r\n  Object.entries(slotEntries).forEach(([key, value]) => {\r\n    let ntarget;\r\n    // const ntarget = componentFn.refs[key];\r\n\r\n    if (key === \"default\" || key === \"children\") {\r\n      ntarget =\r\n        componentFn.el?.querySelector('[data-ref=\"children\"]') ||\r\n        componentFn.el?.querySelector(\"slot:not([name])\");\r\n    } else {\r\n      ntarget = getRef(componentFn.el, key);\r\n    }\r\n    if (!ntarget || value == null) return;\r\n\r\n    // Ensure/reuse boundary if value is a component\r\n    let boundary = ntarget.querySelector(\r\n      \"[data-comp-root='\" + componentFn._id + \"']\"\r\n    );\r\n    if (!boundary && value && typeof value.mount === \"function\") {\r\n      boundary = document.createElement(\"div\");\r\n      boundary.setAttribute(\"data-comp-root\", componentFn._id);\r\n      ntarget.innerHTML = \"\";\r\n      ntarget.appendChild(boundary);\r\n    }\r\n\r\n    const targetForInjection = boundary || ntarget;\r\n    // console.log(\"Injecting slot content\", key, ntarget.outerHTML, value);\r\n    injectSlotContent(targetForInjection, value, api);\r\n  });\r\n}\r\n"],
  "mappings": ";;;;;wbAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,iBAAAE,GAAA,YAAAC,EAAA,oBAAAC,GAAA,gBAAAC,EAAA,eAAAC,GAAA,WAAAC,EAAA,wBAAAC,KCAe,SAARC,EAA0BC,EAAIC,EAAS,CAC5C,GAAI,CAACD,EAAI,MAAO,GAGhB,IAAME,EAAO,SAAS,cAAc,KAAK,EAIzC,GAHAA,EAAK,UAAYD,EAGbC,EAAK,SAAS,SAAW,GAAKA,EAAK,YACrC,OAAAF,EAAG,YAAcE,EAAK,YACf,GAGT,IAAMC,EAAc,MAAM,KAAKD,EAAK,QAAQ,EACtCE,EAAc,MAAM,KAAKJ,EAAG,QAAQ,EAEpCK,EAAW,IAAI,IACfC,EAAW,IAAI,IAErB,QAAWC,KAASJ,EAAa,CAC/B,IAAMK,EAAMD,EAAM,QAAQ,IACtBC,GAAKH,EAAS,IAAIG,EAAKD,CAAK,CAClC,CAEA,QAAWA,KAASH,EAAa,CAC/B,IAAMI,EAAMD,EAAM,QAAQ,IACtBC,GAAKF,EAAS,IAAIE,EAAKD,CAAK,CAClC,CAEA,IAAIE,EAAS,EACb,QAAWC,KAAYP,EAAa,CAClC,IAAMK,EAAME,EAAS,QAAQ,IACzBC,EAAcX,EAAG,SAASS,CAAM,EAEpC,GAAID,GAAOF,EAAS,IAAIE,CAAG,EAAG,CAC5B,IAAMI,EAAWN,EAAS,IAAIE,CAAG,EAEjCK,EAAaD,EAAUF,CAAQ,EAE3BE,IAAaD,GACfX,EAAG,aAAaY,EAAUD,GAAe,IAAI,EAG/CL,EAAS,OAAOE,CAAG,CACrB,MACER,EAAG,aAAaU,EAAUC,GAAe,IAAI,EAG/CF,GACF,CAEA,QAAWK,KAAYR,EAAS,OAAO,EACrCQ,EAAS,OAAO,EAGlB,KAAOd,EAAG,SAAS,OAASG,EAAY,QACtCH,EAAG,UAAU,OAAO,EAGtB,MAAO,EACT,CAEA,SAASa,EAAaE,EAAQC,EAAM,CAClC,GAAID,EAAO,UAAYC,EAAK,QAAS,CACnCD,EAAO,YAAYC,EAAK,UAAU,EAAI,CAAC,EACvC,MACF,CACAC,GAAeF,EAAQC,CAAI,EAC3BE,GAAcH,EAAQC,CAAI,CAC5B,CAEA,SAASC,GAAeF,EAAQC,EAAM,CACpC,IAAMG,EAAYJ,EAAO,WACnBK,EAAUJ,EAAK,WACrB,OAAW,CAAE,KAAAK,CAAK,IAAK,MAAM,KAAKF,CAAS,EACpCH,EAAK,aAAaK,CAAI,GACzBN,EAAO,gBAAgBM,CAAI,EAI/B,OAAW,CAAE,KAAAA,EAAM,MAAAC,CAAM,IAAK,MAAM,KAAKF,CAAO,EAC1CL,EAAO,aAAaM,CAAI,IAAMC,GAChCP,EAAO,aAAaM,EAAMC,CAAK,CAGrC,CAEA,SAASJ,GAAcH,EAAQC,EAAM,CACnC,IAAMO,EAAY,MAAM,KAAKR,EAAO,UAAU,EACxCS,EAAU,MAAM,KAAKR,EAAK,UAAU,EACpCS,EAAM,KAAK,IAAIF,EAAU,OAAQC,EAAQ,MAAM,EAErD,QAAS,EAAI,EAAG,EAAIC,EAAK,IAAK,CAC5B,IAAMC,EAAWH,EAAU,CAAC,EACtBI,EAASH,EAAQ,CAAC,EAExB,GAAI,CAACG,GAAUD,EAAU,CACvBX,EAAO,YAAYW,CAAQ,EAC3B,QACF,CAEA,GAAI,CAACA,GAAYC,EAAQ,CACvBZ,EAAO,YAAYY,EAAO,UAAU,EAAI,CAAC,EACzC,QACF,CAEAC,GAAUF,EAAUC,CAAM,CAC5B,CACF,CAEA,SAASC,GAAUF,EAAUC,EAAQ,CACnC,GAAI,CAAAD,EAAS,YAAYC,CAAM,EAC/B,IAAID,EAAS,WAAaC,EAAO,SAAU,CACzCD,EAAS,YAAYC,EAAO,UAAU,EAAI,CAAC,EAC3C,MACF,CAEID,EAAS,WAAa,KAAK,UACzBA,EAAS,YAAcC,EAAO,YAChCD,EAAS,UAAYC,EAAO,WAG9BD,EAAS,WAAa,KAAK,cAC3BA,EAAS,UAAYC,EAAO,QAE5Bd,EAAaa,EAAUC,CAAM,EAE7BD,EAAS,YAAYC,EAAO,UAAU,EAAI,CAAC,EAE/C,CCjIe,SAARE,EAA4BC,EAAKC,EAAIC,EAAIC,EAAa,CAC3D,GAAI,CAACF,GAAM,CAACC,EAAI,OAChB,IAAME,EAAOH,EAAG,kBAChB,GAAI,CAACG,EAAM,OAEX,SAASC,EAASC,EAAMC,EAAS,GAAO,CACtC,GAAKD,EAEL,CAAI,CAACC,GAAUD,EAAK,cAAgBA,EAAK,aAAa,gBAAgB,EAItE,OAAO,QAAQJ,CAAE,EAAE,QAAQ,CAAC,CAACM,EAAKC,CAAO,IAAM,CAC7C,IAAMC,EAAgBF,EAAI,SAAS,GAAG,EAChC,CAACG,EAAWC,CAAgB,EAAIF,EAClCF,EAAI,MAAM,GAAG,EACbA,EAAI,MAAM,GAAG,EAEXK,EAAkBF,IAAc,KACjBE,EACjB,CAAC,QAAS,QAAS,SAAU,UAAW,QAAQ,EAChD,CAACF,CAAS,GAED,QAASG,GAAS,CAC7B,IAAMC,EAAYC,GAAM,CACtB,IAAMC,EAAeD,EAAE,OAAO,QAAQ,eAAe,EAC/CE,EAAcD,GAAc,QAAQ,QAAU,GAC9CE,EAAcF,GAAc,QAAQ,KAEpCG,EAAcF,EAAY,MAAM,GAAG,EACnCG,EAAaD,EAAY,CAAC,EAC5BE,EAAa,CAAC,EAGlB,GAAIH,EACF,GAAI,CACF,IAAMI,EAAS,KAAK,MAAMJ,CAAW,EACrCG,EAAa,MAAM,QAAQC,CAAM,EAAIA,EAAS,CAACA,CAAM,CACvD,MAAc,CACZ,QAAQ,KAAK,6BAA8BJ,CAAW,CACxD,MAEAG,EAAaF,EAAY,MAAM,CAAC,EAGlC,IAAMI,EAAU,CACd,MAAOR,EACP,MAAOhB,EAAI,MACX,SAAUA,EAAI,SACd,MAAOA,EAAI,MACX,KAAMA,EAAI,KACV,OAAQqB,EACR,KAAMC,CACR,EAGA,GAAIZ,GAAiBO,IAEhBL,IAAqB,KAAOA,IAAqBS,KACjDR,GAAmBG,EAAE,OAASL,GAG/B,OAAOF,EAAQ,KAAKT,EAAKwB,CAAO,EAKpC,GAAI,CAACd,EAAe,CAClB,IAAMe,EAAST,EAAE,OAAO,QAAQJ,GAAoB,GAAG,EACvD,GAAIa,GAAUrB,EAAK,SAASqB,CAAM,EAChC,OAAOhB,EAAQ,KAAKT,EAAKwB,CAAO,CAEpC,CACF,EAEME,EAAS,gBAAgBZ,CAAI,IAAIN,CAAG,GACrCJ,EAAKsB,CAAM,IACdtB,EAAK,iBAAiBU,EAAMC,CAAQ,EACpCX,EAAKsB,CAAM,EAAI,GACfvB,EAAY,KAAK,CAAE,KAAMC,EAAM,KAAAU,EAAM,SAAAC,CAAS,CAAC,EAEnD,CAAC,CACH,CAAC,EAED,QAAWY,KAASrB,EAAK,SACvBD,EAASsB,EAAO,EAAK,EAEzB,CACAtB,EAASJ,EAAI,EAAI,CACnB,CCzFO,SAAS2B,EAAYC,EAAS,CACnC,IAAIC,EAAQD,EACNE,EAAO,IAAI,IAEjB,SAASC,EAASC,EAAM,CACtBH,EAAQ,OAAOG,GAAS,WAAaA,EAAKH,CAAK,EAAI,CAAE,GAAGA,EAAO,GAAGG,CAAK,EACvEF,EAAK,QAASG,GAAOA,EAAGJ,CAAK,CAAC,CAChC,CAEA,SAASK,EAAUD,EAAI,CACrB,OAAAH,EAAK,IAAIG,CAAE,EACXA,EAAGJ,CAAK,EACD,IAAMC,EAAK,OAAOG,CAAE,CAC7B,CAEA,SAASE,GAAM,CACb,OAAON,CACT,CAEA,MAAO,CAAE,IAAAM,EAAK,SAAAJ,EAAU,SAAUI,EAAK,UAAAD,CAAU,CACnD,CAEA,IAAME,EAAW,IAAI,IAERC,EAAU,CACrB,UAAUC,EAAWL,EAAI,CAClBG,EAAS,IAAIE,CAAS,GACzBF,EAAS,IAAIE,EAAW,IAAI,GAAK,EAEnC,IAAMC,EAAMH,EAAS,IAAIE,CAAS,EAClC,OAAAC,EAAI,IAAIN,CAAE,EACH,IAAMM,EAAI,OAAON,CAAE,CAC5B,EAEA,KAAKK,EAAWE,EAAS,CACvB,IAAMD,EAAMH,EAAS,IAAIE,CAAS,EAClC,GAAIC,EACF,QAAWN,KAAMM,EAAKN,EAAGO,CAAO,CAEpC,EAEA,OAAQ,CACNJ,EAAS,MAAM,CACjB,CACF,EAEMK,EAAS,IAAI,IAEZ,SAASC,EAAOC,EAAKf,EAAU,CAAC,EAAG,CACxC,GAAI,CAACa,EAAO,IAAIE,CAAG,EAAG,CACpB,IAAMd,EAAQF,EAAYC,CAAO,EAC3BgB,EAAM,CACV,GAAGf,EACH,KAAKgB,EAAOL,EAAS,CACnBX,EAAM,SAASW,CAAO,EACtBH,EAAQ,KAAK,GAAGM,CAAG,KAAKE,CAAK,GAAIhB,EAAM,SAAS,CAAC,CACnD,EACA,GAAGgB,EAAOZ,EAAI,CACZ,OAAOI,EAAQ,UAAU,GAAGM,CAAG,KAAKE,CAAK,GAAIZ,CAAE,CACjD,CACF,EACAQ,EAAO,IAAIE,EAAKC,CAAG,CACrB,CAEA,OAAOH,EAAO,IAAIE,CAAG,CACvB,CACAD,EAAO,MAAQ,IAAMD,EAAO,MAAM,EClElC,IAAMK,EAAW,CAAC,EAEH,SAARC,EAAqBC,EAAIC,EAAM,CACpC,GAAI,CAACD,EAAI,OAAO,KAGhB,GAAIF,EAASG,CAAI,EAAG,CAClB,IAAMC,EAAgBJ,EAASG,CAAI,EAGnC,GAAIC,EAAc,YAAa,CAE7B,GACEF,EAAG,SAASE,CAAa,GACxBF,EAAG,YACFA,EAAG,aAAe,SAAS,MAC3BA,EAAG,WAAW,SAASE,CAAa,EAEtC,OAAOA,EAGP,OAAOJ,EAASG,CAAI,CAExB,MAEE,OAAOH,EAASG,CAAI,CAExB,CAIA,IAAME,EAAc,SAAS,eAAeF,CAAI,EAChD,GACEE,IACCH,EAAG,SAASG,CAAW,GACrBH,EAAG,YAAcA,EAAG,WAAW,SAASG,CAAW,GAEtD,OAAAL,EAASG,CAAI,EAAIE,EACVA,EAIT,IAAMC,EAAY,CAChB,cAAcH,CAAI,KAClB,eAAeA,CAAI,KACnB,cAAcA,CAAI,KAClB,mBACAA,CACF,EAEA,QAAWI,KAAYD,EAAW,CAChC,IAAIE,EAAeN,EAAG,cAAcK,CAAQ,EAO5C,GANIC,GAMAN,EAAG,aACLM,EAAeN,EAAG,WAAW,cAAcK,CAAQ,EAC/CC,GACF,OAAAR,EAASG,CAAI,EAAIK,EACVA,CAGb,CAEA,OAAO,IACT,CCnEA,IAAMC,EAAmB,IAAI,QAEd,SAARC,EAAmCC,EAASC,EAAOC,EAAK,CAO7D,GALI,CAACF,GAAWC,IAAU,MAKtBH,EAAiB,IAAIE,CAAO,GACfF,EAAiB,IAAIE,CAAO,EAChC,QAAUC,EAEnB,OAIJ,IAAIE,EAAW,OAAOF,GAAU,WAAaA,EAAM,EAAIA,EAavD,GATED,EAAQ,WAAa,QACrB,CAACA,EAAQ,aAAa,MAAM,GAC5BG,GACA,OAAOA,GAAa,UACpB,YAAaA,IAEbA,EAAWA,EAAS,SAGlB,MAAM,QAAQA,CAAQ,EAAG,CAC3B,IAAMC,EAAW,SAAS,uBAAuB,EAEjDD,EAAS,QAASE,GAAa,CAC7B,IAAIC,EAAO,OAAOD,GAAa,WAAaA,EAAS,EAAIA,EACzD,GAAIC,GAAQ,OAAOA,EAAK,OAAU,WAAY,CAC5C,IAAMC,EAAO,SAAS,cAAc,KAAK,EACzC,GAAID,EAAK,UAAU,EACjBA,EAAK,OAAO,EACRA,EAAK,cAAc,aACrBF,EAAS,YAAYE,EAAK,EAAE,MAQ9B,KALAA,EAAK,MAAMC,CAAI,EACVL,EAAI,iBAAiB,SAASI,CAAI,GACrCJ,EAAI,iBAAiB,KAAKI,CAAI,EAGzBC,EAAK,YACVH,EAAS,YAAYG,EAAK,UAAU,CAG1C,SAAWD,GAAM,cAAc,YAC7BF,EAAS,YAAYE,EAAK,EAAE,UACnBA,aAAgB,KACzBF,EAAS,YAAYE,CAAI,UAChB,OAAOA,GAAS,SAAU,CACnC,IAAMC,EAAO,SAAS,cAAc,KAAK,EAEzC,IADAA,EAAK,UAAYD,EACVC,EAAK,YACVH,EAAS,YAAYG,EAAK,UAAU,CAExC,CACF,CAAC,EAEDP,EAAQ,YAAYI,CAAQ,EAC5BN,EAAiB,IAAIE,EAAS,CAAE,MAAAC,CAAM,CAAC,EACvC,MACF,CAGA,GAAIE,GAAY,OAAOA,EAAS,OAAU,WAAY,CACpD,GAAIA,EAAS,UAAU,EAErBA,EAAS,OAAO,EAEZA,EAAS,KAAOH,GAClBA,EAAQ,YAAYG,EAAS,EAAE,MAE5B,CAEL,IAAMI,EAAO,SAAS,cAAc,KAAK,EACzCP,EAAQ,YAAYO,CAAI,EACxBJ,EAAS,MAAMI,CAAI,EACfJ,EAAS,KAAOH,IAClBG,EAAS,GAAKI,EAElB,CACKL,EAAI,iBAAiB,SAASC,CAAQ,GACzCD,EAAI,iBAAiB,KAAKC,CAAQ,CAEtC,SAAWA,GAAU,cAAc,YACjCH,EAAQ,YAAYG,EAAS,EAAE,UACtBA,aAAoB,KAC7BH,EAAQ,YAAYG,CAAQ,UACnB,OAAOA,GAAa,SAAU,CAEvC,IAAMI,EAAO,SAAS,cAAc,KAAK,EACzCA,EAAK,UAAYJ,EAEjB,IAAMC,EAAW,SAAS,uBAAuB,EACjD,KAAOG,EAAK,YACVH,EAAS,YAAYG,EAAK,UAAU,EAEtCP,EAAQ,YAAYI,CAAQ,CAC9B,MACEJ,EAAQ,YAAY,SAAS,eAAe,EAAE,CAAC,EAIjDF,EAAiB,IAAIE,EAAS,CAAE,MAAAC,CAAM,CAAC,CACzC,CC7Ge,SAARO,EAA8BC,EAAaC,EAAOC,EAAKC,EAAc,CAU1E,IAAIC,EAAc,CAAE,GAPlB,OAAOD,GAAiB,WACpBA,EAAa,KAAKD,EAAKD,CAAK,EAC5B,OAAOE,GAAiB,SACxBA,EACA,CAAC,EAG8B,GAAIF,EAAM,OAAS,CAAC,CAAG,GAI1D,OAAOA,EAAM,OAAU,YACvB,MAAM,QAAQA,EAAM,KAAK,KAGzBG,EAAc,CAAE,QAASH,EAAM,KAAM,GAInCA,EAAM,WAAa,OACrBG,EAAY,QAAUH,EAAM,SAClBG,EAAY,UACtBA,EAAY,QAAU,MAKxB,OAAO,QAAQA,CAAW,EAAE,QAAQ,CAAC,CAACC,EAAKC,CAAK,IAAM,CACpD,IAAIC,EAUJ,GAPIF,IAAQ,WAAaA,IAAQ,WAC/BE,EACEP,EAAY,IAAI,cAAc,uBAAuB,GACrDA,EAAY,IAAI,cAAc,kBAAkB,EAElDO,EAAUC,EAAOR,EAAY,GAAIK,CAAG,EAElC,CAACE,GAAWD,GAAS,KAAM,OAG/B,IAAIG,EAAWF,EAAQ,cACrB,oBAAsBP,EAAY,IAAM,IAC1C,EACI,CAACS,GAAYH,GAAS,OAAOA,EAAM,OAAU,aAC/CG,EAAW,SAAS,cAAc,KAAK,EACvCA,EAAS,aAAa,iBAAkBT,EAAY,GAAG,EACvDO,EAAQ,UAAY,GACpBA,EAAQ,YAAYE,CAAQ,GAK9BC,EAF2BD,GAAYF,EAEDD,EAAOJ,CAAG,CAClD,CAAC,CACH,CNvDA,IAAIS,GAAK,EAEIC,GAAc,QAE3B,SAASC,GAAkBC,EAAUC,EAAa,CAChD,QAAWC,KAAO,OAAO,KAAKF,CAAQ,EAC9BE,KAAOD,GACX,OAAO,eAAeA,EAAaC,EAAK,CACtC,KAAM,CACJ,OAAOF,EAASE,CAAG,CACrB,EACA,WAAY,EACd,CAAC,CAGP,CAEA,IAAIC,EAAmB,KAEhB,SAASC,GAAgBC,EAAMC,EAAO,CAAC,EAAG,CAC/C,IAAIC,EACAC,EAAU,CAAC,EAETC,EAAQ,OAAOJ,EAGnBI,IAAU,UACVA,IAAU,WACVJ,IAAS,MACT,CAAC,MAAM,QAAQA,CAAI,GAEnBE,EAAWF,EAAK,OAChBG,EAAU,CAAE,GAAGH,CAAK,EACpB,OAAOG,EAAQ,SAGfD,EAAWF,EACXG,EAAUF,GAAQ,CAAC,GAGrB,GAAI,CACF,MAAOI,EAAe,CAAC,EACvB,GAAAC,EAAK,CAAC,EACN,MAAAC,EAAQ,CAAC,EACT,QAAAC,EACA,UAAAC,EACA,cAAAC,EACA,gBAAAC,EACA,SAAAC,CACF,EAAIT,EAEAU,EAAK,KACLC,EAAU,GACVC,EAAQ,CAAC,EACTC,EAAY,CAAC,EACbC,EAAuB,KACvBC,EAAoB,GACpBC,EAAc,CAAC,EACfC,EAAQf,EACRgB,EAAc,KACdC,EAAgB,GACdC,EAAuB,CAAE,GAAGlB,CAAa,EAC3CmB,EAAkB,GAClBC,EAAgB,CAAC,EAEfC,EAAYC,GAAS,CACzBP,EAAQ,OAAOO,GAAS,WAAaA,EAAKP,CAAK,EAAI,CAAE,GAAGA,EAAO,GAAGO,CAAK,EAClEH,IACHA,EAAkB,GAClBP,EAAuB,CAAE,GAAGF,CAAM,EAClC,eAAe,IAAM,CACnBS,EAAkB,GAClB5B,EAAYqB,CAAoB,EAChCA,EAAuB,IACzB,CAAC,EAEL,EAEMW,EAAM,CACV,KAAM,CAAC,EACP,SAAAF,EACA,MAAAX,EACA,UAAW,IAAMD,EACjB,iBAAkB,CAAC,EAEnB,MAAMe,EAAkBC,EAAe,CAAC,EAAG,CACzC,GAAIhB,GAAWI,EAEb,OAEF,IAAIa,EACF,OAAOF,GAAqB,SACxB,SAAS,cAAcA,CAAgB,EACvCA,EAEN,GAAI,CAACE,EAAQ,MAAM,IAAI,MAAM,uBAAuBF,CAAgB,EAAE,EA2BtEG,EAActB,EAzBE,IAAM,CACpBQ,EAAoB,GACpBL,EAAKkB,EAGLlB,EAAG,aAAa,iBAAkBjB,EAAY,GAAG,EAEjDmB,EAAQ,CAAE,GAAGA,EAAO,GAAGe,CAAa,EACpCd,EAAY,CAAE,GAAGD,CAAM,EACvBa,EAAI,MAAQb,EAEZnB,EAAYmB,CAAK,EAOZO,IACHR,EAAU,GACVN,GAAS,KAAKZ,CAAW,EACzBqC,EAAsB,EAE1B,CAEoC,CACtC,EAEA,OAAOC,EAAQ,CAAC,EAAG,CACjB,GAAI,CAACpB,EAAS,OACd,IAAMqB,EAAYD,EAAM,MAAQA,EAAM,MAAQA,EAExCE,EAAQD,EAAU,GACpBC,GAASA,IAAU9B,IACrBA,EAAK8B,GAGP,IAAMC,EAAS,CAAE,GAAGtB,EAAO,GAAGoB,CAAU,EACxCnB,EAAY,CAAE,GAAGD,CAAM,EACvBA,EAAQsB,EACRT,EAAI,MAAQb,EAEZnB,EAAYmB,CAAK,CACnB,EAEA,OAAOuB,EAAW,CAAC,EAAG,CACpBvB,EAAQ,CAAE,GAAGA,EAAO,GAAGuB,CAAS,EAChCV,EAAI,MAAQb,EACZ,IAAIwB,EACF,OAAOrC,GAAa,WAChBA,EAAS,KAAK0B,EAAK,CAAE,MAAAR,EAAO,SAAAM,EAAU,MAAAX,EAAO,KAAMa,EAAI,IAAK,CAAC,EAC7D1B,EAEN,OAAIqC,IACFA,EAAO,IAAI,OAAOA,CAAI,EACtBA,EAAK,IAAM3C,EAAY,KAGzBF,GAAkBkC,EAAKhC,CAAW,EAC3B2C,CACT,EAEA,eAAgB,IAAM,CACpBX,EAAI,iBAAiB,QAASY,GAAU,CAClCA,GAAS,OAAOA,EAAM,SAAY,YACpCA,EAAM,QAAQ,CAElB,CAAC,EACDZ,EAAI,iBAAmB,CAAC,EACxBP,EAAc,KACdC,EAAgB,GAChBT,EAAK,KACLC,EAAU,GACVI,EAAoB,GACpBC,EAAc,CAAC,EACfJ,EAAQ,CAAC,EACTC,EAAY,CAAC,EACbI,EAAQ,CAAE,GAAGG,CAAqB,CACpC,EAEA,SAAU,CACR,GAAI,CAACT,GAAW,CAACD,EAAI,OAwBrBmB,EAAcrB,EAtBE,IAAM,CAChBE,EAAG,aACLQ,EAAcR,EAAG,WAAW,UAAU,EAAI,EAC1CA,EAAG,YAAYA,EAAG,UAAU,GAG9BM,EAAY,QAAQ,CAAC,CAAE,KAAAsB,EAAM,KAAAC,EAAM,SAAAC,CAAS,IAAM,CAChDF,EAAK,oBAAoBC,EAAMC,CAAQ,CACzC,CAAC,EACDxB,EAAc,CAAC,EAEfM,EAAc,QAASmB,GAAUA,EAAM,CAAC,EACxCnB,EAAgB,CAAC,EAEjBX,EAAU,GACVI,EAAoB,GACpBI,EAAgB,GAChBb,GAAW,KAAKmB,CAAG,EAEfA,EAAI,gBAAgBA,EAAI,eAAe,CAC7C,CAEsC,CACxC,EAEA,IAAI,UAAW,CACb,OAAO1B,CACT,EACA,IAAI,IAAK,CACP,OAAOW,CACT,EACA,IAAI,OAAQ,CACV,OAAOO,CACT,CACF,EAEAQ,EAAI,IAAM,SAAUiB,EAAM,CACxB,OAAOC,EAAO,KAAK,GAAID,CAAI,CAC7B,EAEAjB,EAAI,KAAO,IAAI,MACb,CAAC,EACD,CACE,IAAImB,EAAGlD,EAAK,CACV,OAAO+B,EAAI,IAAI/B,CAAG,CACpB,CACF,CACF,EAEA+B,EAAI,OAAS,SAAUoB,EAAG,CACxB,OAAOA,EAAE,OAAO,QAAQ,eAAe,GAAG,QAAQ,QAAU,IAC9D,EAEA,SAASf,GAAwB,CAC/BR,EAAgB,CAAC,EACjB,OAAO,QAAQnB,CAAE,EAAE,QAAQ,CAAC,CAACT,EAAKoD,CAAO,IAAM,CAC7C,GAAIpD,EAAI,SAAS,IAAI,EAAG,CACtB,IAAMqD,EAAQD,EAAQ,KAAKrB,CAAG,EACxBgB,EAAQO,EAAQ,UAAUtD,EAAKqD,CAAK,EAC1CzB,EAAc,KAAKmB,CAAK,CAC1B,CACF,CAAC,CACH,CAEA,SAASQ,EAAOC,EAAc,CAC5BtC,EAAQ,CAAE,GAAGa,EAAI,MAAO,GAAGyB,CAAa,EACxCzB,EAAI,MAAQb,EAER,CAACF,GAAMA,EAAG,YAKd,IAAM0B,EAAOX,EAAI,OAAOb,CAAK,EAE7B,GAAIwB,IAAS,MAAQA,IAAS,GAAI,CAC5B,CAACjB,GAAiBT,GAAMA,EAAG,YAE7BQ,EADiBR,EAAG,WACG,UAAU,EAAI,EACrCmB,EAAcrB,EAAiB,IAAM,CAEnCE,EAAG,UAAY,GACfM,EAAY,QAAQ,CAAC,CAAE,KAAAsB,EAAM,KAAAC,EAAM,SAAAC,CAAS,IAAM,CAChDF,EAAK,oBAAoBC,EAAMC,CAAQ,CACzC,CAAC,EACDxB,EAAc,CAAC,EACfL,EAAU,GACVQ,EAAgB,GAChBb,GAAW,KAAKmB,CAAG,CACrB,CAAC,GAEDN,EAAgB,GAElB,MACF,CAEA,GAAIA,GAAiBD,EAAa,CAChCR,EAAG,YAAYQ,CAAW,EAC1BA,EAAc,KACdC,EAAgB,GAChBR,EAAU,GACVwC,EAAW1B,EAAKf,EAAIP,EAAIa,CAAW,EACnCX,GAAS,KAAKoB,CAAG,EACjB,MACF,CAEA,OAAA2B,EAAS1C,EAAI0B,CAAI,EACjBiB,EAAa5D,EAAamB,EAAOa,EAAKrB,CAAK,EAI3C+C,EAAW1B,EAAKf,EAAIP,EAAIa,CAAW,EAE/BL,GAAWF,GACbA,EAAS,KAAKgB,EAAKZ,CAAS,EAE9BM,EAAgB,GACTiB,CACT,CAEA,SAASP,EAAcyB,EAAM9B,EAAM,CAC7B8B,EACEA,EAAK,OAAQA,EAAK,KAAK7B,EAAKD,CAAI,EAC/B,QAAQ,QAAQ8B,EAAK,KAAK7B,CAAG,CAAC,EAAE,KAAKD,CAAI,EAE9CA,EAAK,CAET,CAEA,IAAI+B,EAAW,GAEf,SAAS9D,EAAYmB,EAAQ,CAAC,EAAG,CAC/B,OAAAjB,EAAmBF,EACnB8D,EAAW9D,EAAY,QAAQmB,CAAK,EACpCjB,EAAmB,KACZF,CACT,CAIA,OAAAA,EAAY,SAAW,UAAY,CACjC,OAAO8D,EAAW,OAAOA,CAAQ,EAAI,EACvC,EAGA,OAAO,OAAO9D,EAAagC,CAAG,EAG9B,CAAC,KAAM,QAAS,QAAS,UAAU,EAAE,QAAS/B,GAAQ,CACpD,OAAO,eAAeD,EAAaC,EAAK,CACtC,KAAM,CACJ,OAAO+B,EAAI/B,CAAG,CAChB,EACA,WAAY,GACZ,aAAc,EAChB,CAAC,CACH,CAAC,EAEDD,EAAY,QAAUwD,EACtBxD,EAAY,OAASgC,EAAI,OACzBhC,EAAY,IAAMJ,KAEXI,CACT,CAEO,SAAS+D,GACdC,EACA1D,EACA2D,EAASC,GAASA,EAAK,IAAMA,EAAK,KAAOA,EACzC,CACA,OAAOF,EACJ,IAAI,CAACE,EAAMC,IAAU,CACpB,IAAMlE,EAAMgE,EAAMC,EAAMC,CAAK,EACvBC,EAAQ9D,EAAS4D,EAAMC,CAAK,EAElC,OAAI,OAAOC,GAAU,SACZA,EAAM,QACX,oBACA,iBAAiB,OAAOnE,CAAG,EAAE,QAAQ,KAAM,QAAQ,CAAC,GACtD,EAEKmE,CACT,CAAC,EACA,KAAK,EAAE,CACZ,CAGO,SAASC,IAAsB,CACpC,OAAOnE,CACT",
  "names": ["reactive_core_exports", "__export", "__VERSION__", "context", "createComponent", "createState", "renderList", "shared", "useCurrentComponent", "diffHTML", "el", "newHTML", "temp", "newChildren", "oldChildren", "newKeyed", "oldKeyed", "child", "key", "cursor", "newChild", "currentNode", "existing", "patchElement", "leftover", "fromEl", "toEl", "syncAttributes", "patchChildren", "fromAttrs", "toAttrs", "name", "value", "fromNodes", "toNodes", "max", "fromNode", "toNode", "patchNode", "bindEvents", "api", "el", "on", "boundEvents", "root", "traverse", "node", "isRoot", "key", "handler", "isColonSyntax", "eventType", "actionOrSelector", "isWildcardEvent", "type", "listener", "e", "actionTarget", "actionValue", "dataArgsRaw", "actionParts", "actionName", "actionArgs", "parsed", "context", "target", "marker", "child", "createState", "initial", "state", "subs", "setState", "next", "fn", "subscribe", "get", "channels", "context", "eventName", "set", "payload", "stores", "shared", "key", "api", "event", "refCache", "ref", "el", "name", "cachedElement", "elementById", "selectors", "selector", "foundElement", "slotContentCache", "injectSlotContent", "refNode", "value", "api", "resolved", "fragment", "origItem", "item", "temp", "hydrateSlots", "componentFn", "props", "api", "initialSlots", "slotEntries", "key", "value", "ntarget", "ref", "boundary", "injectSlotContent", "id", "__VERSION__", "syncInstanceToAPI", "instance", "componentFn", "key", "currentComponent", "createComponent", "arg1", "arg2", "renderFn", "options", "ftype", "initialState", "on", "slots", "onMount", "onUnmount", "onBeforeMount", "onBeforeUnmount", "onUpdate", "el", "mounted", "props", "prevProps", "scheduledRenderProps", "onBeforeMountDone", "boundEvents", "state", "_cachedNode", "_renderedNull", "originalInitialState", "renderScheduled", "contextUnsubs", "setState", "next", "api", "targetOrSelector", "initialProps", "target", "runBeforeHook", "setupContextListeners", "input", "nextProps", "newOn", "merged", "newProps", "html", "child", "node", "type", "listener", "unsub", "name", "ref", "_", "e", "handler", "bound", "context", "render", "currentProps", "bindEvents", "diffHTML", "hydrateSlots", "hook", "lastHtml", "renderList", "array", "keyFn", "item", "index", "inner", "useCurrentComponent"]
}
