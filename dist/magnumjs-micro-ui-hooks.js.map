{
  "version": 3,
  "sources": ["../lib/hooks/index.js", "../lib/reactive-core.js", "../lib/hooks/useFetch.js", "../lib/hooks/useContext.js", "../lib/hooks/useState.js", "../lib/hooks/useEffect.js"],
  "sourcesContent": ["export * from \"./useFetch.js\";\r\nexport * from \"./useContext.js\";\r\nexport * from \"./useState.js\";\r\nexport * from \"./useEffect.js\";\r\n", "import diffHTML from \"./diffHTML.js\";\r\nimport bindEvents from \"./bindEvents.js\";\r\nimport { context, createChannelMap } from \"./reactive-core-helpers/context.js\";\r\nimport getRef from \"./get-refs.js\";\r\nimport hydrateSlots from \"./hydrateSlots.js\";\r\nimport hydrateActions from \"./hydrateActions.js\";\r\nimport { runHook } from \"./reactive-core-helpers/runHook.js\";\r\nimport { runBeforeHook } from \"./reactive-core-helpers/runBeforeHook.js\";\r\nimport { syncInstanceToAPI } from \"./reactive-core-helpers/syncInstanceToAPI.js\";\r\nlet id = 1;\r\n\r\nexport const __VERSION__ = process.env.APP_VERSION || \"\";\r\n\r\nexport const globalComponentRegistry = new Map();\r\n\r\nexport function registerComponent(instance) {\r\n  if (!instance._id) return;\r\n  //   instance._id = `comp-${Math.random().toString(36).slice(2)}`;\r\n  globalComponentRegistry.set(instance._id, instance);\r\n}\r\n\r\nexport function unregisterComponent(instance) {\r\n  if (instance._id) globalComponentRegistry.delete(instance._id);\r\n}\r\n\r\nexport function getComponentById(id) {\r\n  return globalComponentRegistry.get(id);\r\n}\r\n\r\nlet currentComponent = null;\r\n\r\n// --- INTERNAL: clone a component from a frozen template (no mount yet) ---\r\nfunction __cloneFromTemplate(sourceComp, initialProps = {}) {\r\n  const tpl = sourceComp._frozenTemplate;\r\n  // Rebuild a fresh callable component from the same render + options\r\n  // merge these initialProps with the instance props\r\n  const clone = createComponent(tpl.renderFn, tpl.options);\r\n  // Stash initial props to apply on first mount/update\r\n  clone._initialProps = initialProps;\r\n  // clone.props = { ...initialProps };\r\n  // For debugging / safety, remember who produced this clone\r\n  clone._templateSource = sourceComp;\r\n\r\n  // console.log(\"Cloning component:\", clone.props);\r\n\r\n  return clone;\r\n}\r\n\r\nexport function createComponent(arg1, arg2 = {}) {\r\n  let renderFn;\r\n  let options = {};\r\n\r\n  const ftype = typeof arg1;\r\n  // Detect object-style usage\r\n  if (\r\n    ftype === \"object\" &&\r\n    ftype !== \"function\" &&\r\n    arg1 !== null &&\r\n    !Array.isArray(arg1)\r\n  ) {\r\n    renderFn = arg1.render;\r\n    options = { ...arg1 };\r\n    delete options.render; // avoid duplicate\r\n  } else {\r\n    // Old signature: createComponent(renderFn, options)\r\n    renderFn = arg1;\r\n    options = arg2 || {};\r\n  }\r\n\r\n  let {\r\n    state: initialState = {},\r\n    on = {},\r\n    slots = {},\r\n    onMount,\r\n    onUnmount,\r\n    onBeforeMount,\r\n    onBeforeUnmount,\r\n    onUpdate,\r\n    ...custom\r\n  } = options;\r\n\r\n  let el = null;\r\n  let mounted = false;\r\n  let props = {};\r\n  let prevProps = {};\r\n  let scheduledRenderProps = null;\r\n  let onBeforeMountDone = false;\r\n  let boundEvents = [];\r\n  let state = initialState;\r\n  let _cachedNode = null;\r\n  let _renderedNull = false;\r\n  const originalInitialState = { ...initialState };\r\n  let renderScheduled = false;\r\n  let contextUnsubs = [];\r\n  const localBus = createChannelMap();\r\n\r\n\r\n  const setState = (next) => {\r\n    state = typeof next === \"function\" ? next(state) : { ...state, ...next };\r\n    if (!renderScheduled) {\r\n      renderScheduled = true;\r\n      scheduledRenderProps = { ...props };\r\n      queueMicrotask(() => {\r\n        renderScheduled = false;\r\n        componentFn(scheduledRenderProps);\r\n        scheduledRenderProps = null;\r\n      });\r\n    }\r\n  };\r\n\r\n  const api = {\r\n    refs: {},\r\n    on: function (event, handler) {\r\n      if (event && handler) {\r\n        const id = `h${componentFn._renderIndex++}`; // stable per render cycle\r\n        componentFn.addEvent(`${event} [data-ref=${id}]`, handler);\r\n        return `data-ref=\"${id}\"`;\r\n      }\r\n    },\r\n    setState,\r\n    props,\r\n    _childCallCache: {}, // per-parent render-order child instance cache\r\n    _childCallIndex: 0, // increments every time a child() is called during this render\r\n    isMounted: () => mounted,\r\n    _renderIndex: 0,\r\n    _mountedChildren: [],\r\n    _unmountCbs: [],\r\n    _mountCbs: [],\r\n    _beforeMountCbs: [],\r\n    _updateCbs: [],\r\n    _beforeUnmountCbs: [],\r\n\r\n    // runtime-attachable mount\r\n    onMount(fn) {\r\n      if (typeof fn === \"function\") this._mountCbs.push(fn);\r\n    },\r\n    // runtime-attachable cleanup\r\n    onUnmount(fn) {\r\n      if (typeof fn === \"function\") this._unmountCbs.push(fn);\r\n    },\r\n    // runtime-attachable before mount\r\n    onBeforeMount(fn) {\r\n      if (typeof fn === \"function\") this._beforeMountCbs.push(fn);\r\n    },\r\n    onBeforeUnmount(fn) {\r\n      if (typeof fn === \"function\") this._beforeUnmountCbs.push(fn);\r\n    },\r\n    // runtime-attachable before mount\r\n    onUpdate(fn) {\r\n      if (typeof fn === \"function\") this._updateCbs.push(fn);\r\n    },\r\n\r\n    // local (component-scoped) events\r\n    emit(event, payload) {\r\n      localBus.emit(event, payload);\r\n    },\r\n    onEmit(event, fn) {\r\n      const unsub = localBus.subscribe(event, fn);\r\n      this.onUnmount(unsub);\r\n      return unsub;\r\n    },\r\n\r\n    // global events passthrough (optional helpers)\r\n    emitGlobal(event, payload) {\r\n      context.emit(event, payload);\r\n    },\r\n    onEmitGlobal(event, fn) {\r\n      const unsub = context.subscribe(event, fn);\r\n      this.onUnmount(unsub);\r\n      return unsub;\r\n    },\r\n\r\n    addEvent(key, handler) {\r\n      if (!api.on[key]) api.on[key] = handler;\r\n    },\r\n\r\n    mount(targetOrSelector, initialProps = {}) {\r\n      if (mounted || onBeforeMountDone) {\r\n        //  console.log(\"Component already mounted or mounting in progress\", componentFn._id);\r\n        return;\r\n      }\r\n      let target =\r\n        typeof targetOrSelector === \"string\"\r\n          ? document.querySelector(targetOrSelector)\r\n          : targetOrSelector;\r\n\r\n      if (!target) throw new Error(`No element matches: ${targetOrSelector}`);\r\n\r\n      const proceed = () => {\r\n        onBeforeMountDone = true;\r\n        el = target;\r\n        // console.log(\"Mounting component\", componentFn._id, el);\r\n        // Mark this as a component root for event isolation\r\n        el.setAttribute(\r\n          \"data-comp-root\",\r\n          componentFn._id + \"-\" + (renderFn.name || \"\")\r\n        );\r\n\r\n        props = { ...props, ...initialProps };\r\n        prevProps = { ...props };\r\n        api.props = props;\r\n\r\n        // Attach the component instance for ref lookups\r\n        el._componentInstance = componentFn;\r\n\r\n        if (props.key) {\r\n          el.setAttribute(\"data-key\", props.key);\r\n        }\r\n\r\n        componentFn(props);\r\n\r\n        // \u2705 Automatically hydrate component instances passed to props.children or props.slots\r\n        // hydrateSlots(componentFn, props, api, slots);\r\n\r\n        //bindEvents(api, el, on, api._boundEvents); // Ensure `on` from options is passed correctly\r\n\r\n        if (!_renderedNull) {\r\n          mounted = true;\r\n          //onMount?.call(componentFn);\r\n          runHook(api._mountCbs, undefined, false, componentFn);\r\n          setupContextListeners();\r\n        }\r\n      };\r\n\r\n      // Execute onBeforeMount callbacks\r\n      //runHook(api._beforeMountCbs);\r\n\r\n      runBeforeHook(api._beforeMountCbs, proceed, componentFn);\r\n    },\r\n\r\n    update(input = {}) {\r\n      if (!mounted) return;\r\n      const nextProps = input.props ? input.props : input;\r\n\r\n      const newOn = nextProps.on;\r\n      if (newOn) {\r\n        Object.assign(api.on, newOn);\r\n      }\r\n\r\n      const merged = { ...props, ...nextProps };\r\n      prevProps = { ...props };\r\n      props = merged;\r\n      api.props = props;\r\n\r\n      // reset data-key if props.key changes\r\n      if (props.key !== prevProps.key) {\r\n        el.setAttribute(\"data-key\", props.key);\r\n      }\r\n\r\n      componentFn(props);\r\n    },\r\n\r\n    render(newProps = {}) {\r\n      props = { ...props, ...newProps };\r\n      api.props = props;\r\n      let html =\r\n        typeof renderFn === \"function\"\r\n          ? renderFn.call(api, { state, setState, props, refs: api.refs })\r\n          : renderFn;\r\n\r\n      if (html) {\r\n        html = new String(html);\r\n        html._id = componentFn._id;\r\n      }\r\n\r\n      syncInstanceToAPI(api, componentFn);\r\n      return html;\r\n    },\r\n\r\n    _resetInternal: () => {\r\n      api._mountedChildren.forEach((child) => {\r\n        if (child && typeof child.unmount === \"function\") {\r\n          child.unmount();\r\n        }\r\n      });\r\n      api._mountedChildren = [];\r\n      _cachedNode = null;\r\n      _renderedNull = false;\r\n      el = null; // <-- Add this line\r\n      mounted = false;\r\n      onBeforeMountDone = false;\r\n      boundEvents = [];\r\n      props = {};\r\n      prevProps = {};\r\n      state = { ...originalInitialState };\r\n    },\r\n\r\n    unmount() {\r\n      if (!mounted || !el) return;\r\n\r\n      const cleanup = () => {\r\n        if (el.firstChild) {\r\n          _cachedNode = el.firstChild.cloneNode(true);\r\n          el.removeChild(el.firstChild);\r\n        }\r\n\r\n        runHook(api._unmountCbs, undefined, true, componentFn);\r\n\r\n        localBus.clear(); // clear local listeners\r\n\r\n        boundEvents.forEach(({ node, type, listener }) => {\r\n          node.removeEventListener(type, listener);\r\n        });\r\n        boundEvents = [];\r\n\r\n        contextUnsubs.forEach((unsub) => unsub());\r\n        contextUnsubs = [];\r\n\r\n        mounted = false;\r\n        onBeforeMountDone = false;\r\n        _renderedNull = true;\r\n        // onUnmount?.call(api);\r\n\r\n        unregisterComponent(componentFn); // <-- remove from registry\r\n        if (api._resetInternal) api._resetInternal();\r\n      };\r\n\r\n      runBeforeHook(api._beforeUnmountCbs, cleanup, api);\r\n    },\r\n\r\n    get renderFn() {\r\n      return renderFn;\r\n    },\r\n    get el() {\r\n      return el;\r\n    },\r\n    get state() {\r\n      return state;\r\n    },\r\n  };\r\n\r\n  // Register option lifecycles into arrays\r\n  if (onMount) api.onMount(onMount);\r\n  if (onUnmount) api.onUnmount(onUnmount);\r\n  if (onBeforeMount) api.onBeforeMount(onBeforeMount);\r\n  if (onBeforeUnmount) api.onBeforeUnmount(onBeforeUnmount);\r\n  if (onUpdate) api.onUpdate(onUpdate);\r\n\r\n  // overrides defaults\r\n  Object.assign(api.on, on);\r\n\r\n  api.ref = function (name) {\r\n    return getRef(this.el, name);\r\n  };\r\n\r\n  api.refs = new Proxy(\r\n    {},\r\n    {\r\n      get(_, key) {\r\n        return api.ref(key);\r\n      },\r\n    }\r\n  );\r\n\r\n\r\n  function setupContextListeners() {\r\n    contextUnsubs = [];\r\n    Object.entries(api.on).forEach(([key, handler]) => {\r\n      if (key.includes(\"::\")) {\r\n        componentFn.onEmitGlobal(key, handler.bind(api));\r\n      }\r\n      // else if it doesn't include any spaces * or : we can treat as a local listener\r\n      else if (!key.includes(\" \") && !key.includes(\"*\") && !key.includes(\":\")) {\r\n        componentFn.onEmit(key, handler.bind(api));\r\n      }\r\n    });\r\n  }\r\n\r\n  function render(currentProps) {\r\n    props = { ...api.props, ...currentProps };\r\n    api.props = props;\r\n\r\n    if (!el || el.isConnected === false) {\r\n      //console.warn(\"Component root element is not connected to the DOM, skipping render:\", componentFn._id, componentFn.renderFn())\r\n      //return;\r\n    }\r\n\r\n    const html = api.render(props);\r\n\r\n    if (html === null || html === \"\") {\r\n      if (!_renderedNull && el && el.firstChild) {\r\n        const realNode = el.firstChild;\r\n        _cachedNode = realNode.cloneNode(true);\r\n        runBeforeHook(\r\n          api._beforeUnmountCbs,\r\n          () => {\r\n            // Remove all child nodes, not just first\r\n            el.innerHTML = \"\";\r\n            boundEvents.forEach(({ node, type, listener }) => {\r\n              node.removeEventListener(type, listener);\r\n            });\r\n            boundEvents = [];\r\n            mounted = false;\r\n            _renderedNull = true;\r\n            // onUnmount?.call(api);\r\n            runHook(api._unmountCbs, undefined, true, componentFn);\r\n          },\r\n          api\r\n        );\r\n      } else {\r\n        _renderedNull = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (_renderedNull && _cachedNode) {\r\n      el.appendChild(_cachedNode);\r\n      _cachedNode = null;\r\n      _renderedNull = false;\r\n      mounted = true;\r\n      bindEvents(api, el, api.on, boundEvents);\r\n      // onMount?.call(api);\r\n      runHook(api._mountCbs, undefined, false, componentFn);\r\n      return;\r\n    }\r\n\r\n    diffHTML(el, html);\r\n    hydrateSlots(componentFn, props, api, slots);\r\n    hydrateActions(componentFn, el);\r\n    //    console.log(\"Rendered HTML:\", html, el === null ? \"null\" : el.outerHTML, el === componentFn.el, el.isConnected)\r\n\r\n    bindEvents(api, el, api.on, boundEvents);\r\n\r\n    if (mounted) {\r\n      // onUpdate.call(api, prevProps);\r\n      runHook(api._updateCbs, prevProps, false, componentFn);\r\n    }\r\n\r\n    _renderedNull = false;\r\n    return html;\r\n  }\r\n\r\n  let lastHtml = \"\";\r\n  // Create the callable component function\r\n  function componentFn(props = {}) {\r\n    // console.log(\"caller\", componentFn._fromSlotHydration, props, componentFn._id);\r\n    // if (props._fromSlotHydration) {\r\n    //   // console.log('slot hydration call, skip child logic', props);\r\n    // } else {\r\n    //   // console.log('normal call', props);\r\n    // }\r\n    // If we are inside ANOTHER component's render, this is a child call.\r\n    if (\r\n      !componentFn._fromSlotHydration &&\r\n      currentComponent &&\r\n      currentComponent !== componentFn\r\n    ) {\r\n      // Short-circuit: if called from slot hydration, just return instance\r\n\r\n      // Child call inside parent render\r\n      const parent = currentComponent;\r\n      if (parent._childCallIndex == null) parent._childCallIndex = 0;\r\n      if (!parent._childCallCache) parent._childCallCache = {};\r\n      const cacheKey = props.key != null ? props.key : parent._childCallIndex++;\r\n      let inst = parent._childCallCache[cacheKey];\r\n      if (!inst || inst._templateSource !== componentFn) {\r\n        // console.log(\"Child component detected:\", componentFn._id, currentComponent._id, props);\r\n        inst = __cloneFromTemplate(componentFn, props);\r\n        inst._prevProps = { ...props };\r\n\r\n        inst.toString = () => {\r\n          // return inst._id\r\n          return `<div data-comp=\"${inst._id}\"></div>`;\r\n        };\r\n        parent._childCallCache[cacheKey] = inst;\r\n      } else {\r\n        // console.log(\"Reusing existing child instance:\", inst._id, props, inst.isMounted());\r\n\r\n        // Always update child instance with latest props\r\n        inst._prevProps = { ...props };\r\n        inst.update(props);\r\n      }\r\n\r\n      // if props.key then add to el data-key\r\n\r\n      return inst;\r\n    }\r\n    // Normal top-level render of THIS component\r\n    currentComponent = componentFn;\r\n    componentFn._renderIndex = 0;\r\n    componentFn._childCallIndex = 0;\r\n    componentFn._prevProps = props;\r\n    // console.log('call render for', componentFn._id, props);\r\n    // Reset child call index for this render pass\r\n    lastHtml = componentFn._render(props);\r\n    currentComponent = null;\r\n    return componentFn;\r\n  }\r\n\r\n  // Add toString method to componentFn\r\n\r\n  componentFn.toString = function () {\r\n    // If we haven't produced HTML yet, emit a placeholder wrapper so the parent\r\n    // can locate and mount this instance by ID.\r\n    // But only when within a parent component\r\n    if (\r\n      !lastHtml ||\r\n      (String(lastHtml) === \"\" &&\r\n        !componentFn.isMounted() &&\r\n        currentComponent !== null &&\r\n        currentComponent._id !== componentFn._id)\r\n    ) {\r\n      return String(componentFn._id);\r\n      //return `<div data-comp=\"${componentFn._id}\"></div>`;\r\n    }\r\n    return lastHtml ? String(lastHtml) : \"\";\r\n  };\r\n\r\n  // Attach API methods\r\n  Object.assign(componentFn, api, custom);\r\n\r\n  // Dynamically attach instance-backed getters\r\n  [\"el\", \"props\", \"state\", \"setState\"].forEach((key) => {\r\n    Object.defineProperty(componentFn, key, {\r\n      get() {\r\n        return api[key];\r\n      },\r\n      enumerable: true,\r\n      configurable: false,\r\n    });\r\n  });\r\n\r\n  componentFn._render = render;\r\n  componentFn.render = api.render;\r\n  componentFn._id = id++;\r\n  componentFn.getId = () => componentFn._id;\r\n  registerComponent(componentFn); // <-- auto register\r\n\r\n  // Freeze a template of the original definition so we can clone later\r\n  componentFn._frozenTemplate = Object.freeze({\r\n    renderFn,\r\n    // use the original options shape but ensure state is not aliased\r\n    options: { ...options, state: { ...originalInitialState } },\r\n  });\r\n\r\n  return componentFn;\r\n}\r\n\r\n// Moved to reactive-core-helpers/renderList.js\r\nimport { renderList } from \"./reactive-core-helpers/renderList.js\";\r\nexport { renderList };\r\n\r\n// Usage in composables:\r\nexport function useCurrentComponent() {\r\n  return currentComponent;\r\n}\r\n", "// useFetch.js\r\nimport { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\nexport function useFetch(url, options = {}) {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error('useFetch must be called inside a component render or lifecycle');\r\n\r\n  // Initialize component state only once per component instance\r\n  if (!comp.state || (comp.state.data === undefined && comp.state.loading === undefined && comp.state.error === undefined)) {\r\n    comp.setState({ data: null, loading: true, error: null });\r\n  }\r\n\r\n  async function run() {\r\n    comp.setState(s => ({ ...s, loading: true }));\r\n    console.log('fetch started');\r\n    try {\r\n      const res = await fetch(url, options);\r\n      const data = await res.json();\r\n      comp.setState({ data, error: null, loading: false });\r\n      console.log('fetch success', { data });\r\n      comp.emit(\"fetch::done\", { url, data });\r\n    } catch (error) {\r\n      comp.setState({ data: null, error, loading: false });\r\n      console.log('fetch error', { error });\r\n      comp.emit(\"fetch::error\", { url, error });\r\n    }\r\n  }\r\n\r\n  comp.onMount(run);\r\n  comp.onEmit(\"fetch::refresh\", run);\r\n\r\n  return {\r\n    get: () => ({ ...comp.state }),\r\n    subscribe: (fn) => {\r\n      // Simple subscription: call fn on update\r\n      comp.onUpdate(() => fn({ ...comp.state }));\r\n      // Return unsubscribe (not implemented here)\r\n      return () => {};\r\n    },\r\n    refresh: run\r\n  };\r\n}\r\n", "import { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\n// -------------------------\r\n// useContext\r\n// -------------------------\r\nconst globalContexts = {}; // key \u2192 { value, subs:Set }\r\n\r\nexport function useContext(key, defaultValue = {}) {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error(\"useContext() must be inside render()\");\r\n\r\n  if (!globalContexts[key]) {\r\n    globalContexts[key] = {\r\n      value: defaultValue,\r\n      subs: new Set()\r\n    };\r\n  }\r\n\r\n  const ctx = globalContexts[key];\r\n  ctx.subs.add(comp);\r\n\r\n  comp.onUnmount(() => ctx.subs.delete(comp));\r\n\r\n  const setValue = (next) => {\r\n    ctx.value =\r\n      typeof next === \"function\" ? next(ctx.value) : next;\r\n    ctx.subs.forEach(c => c.update());\r\n  };\r\n\r\n  return [ctx.value, setValue];\r\n}\r\n", "// hooks.js\r\nimport { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\n// -------------------------\r\n// useState\r\n// -------------------------\r\nexport function useState(initial) {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error(\"useState must be inside render()\");\r\n\r\n  // --- auto-setters for default state, run once ---\r\n  if (!comp._hasStateSetters) {\r\n    if (comp.state) {\r\n      Object.keys(comp.state).forEach(key => {\r\n        const setterName = \"set\" + key.charAt(0).toUpperCase() + key.slice(1);\r\n        if (!comp[setterName]) {\r\n          comp[setterName] = (next) => {\r\n            const value = comp.state[key];\r\n            const newValue = typeof next === \"function\" ? next(value) : next;\r\n            if (newValue !== value) {\r\n              comp.state[key] = newValue;\r\n              comp.update();\r\n            }\r\n          };\r\n        }\r\n      });\r\n    }\r\n    comp._hasStateSetters = true;\r\n  }\r\n // --- dynamic hook state ---\r\n  const hookIndex = comp._renderIndex++;\r\n  if (!comp._hooks) comp._hooks = [];\r\n  if (comp._hooks[hookIndex] === undefined) {\r\n    comp._hooks[hookIndex] =\r\n      typeof initial === \"function\" ? initial() : initial;\r\n  }\r\n\r\n  const setValue = (next) => {\r\n    const value = comp._hooks[hookIndex];\r\n    const newValue =\r\n      typeof next === \"function\" ? next(value) : next;\r\n    if (newValue !== value) {\r\n      comp._hooks[hookIndex] = newValue;\r\n      comp.update();\r\n    }\r\n  };\r\n\r\n  return [comp._hooks[hookIndex], setValue];\r\n}\r\n\r\n", "import { useCurrentComponent } from \"../reactive-core.js\";\r\n// -------------------------\r\n// useEffect\r\n// -------------------------\r\nexport function useEffect(effect, deps = []) {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error(\"useEffect must be inside render()\");\r\n\r\n  const hookIndex = comp._renderIndex++;\r\n  comp._hooks = comp._hooks || [];\r\n  const prevDeps = comp._hooks[hookIndex] || [];\r\n\r\n  const changed =\r\n    deps.length === 0 || deps.some((d, i) => d !== prevDeps[i]);\r\n\r\n  if (changed) {\r\n    let cleanup;\r\n    comp.onUnmount(() => cleanup && cleanup());\r\n    cleanup = effect();\r\n    comp._hooks[hookIndex] = deps;\r\n    // comp.update();\r\n  }\r\n}\r\n"],
  "mappings": "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",
  "names": ["hooks_exports", "__export", "useContext", "useEffect", "useFetch", "useState", "currentComponent", "useCurrentComponent", "currentComponent", "useFetch", "url", "options", "comp", "useCurrentComponent", "run", "s", "data", "error", "fn", "globalContexts", "useContext", "key", "defaultValue", "comp", "useCurrentComponent", "ctx", "setValue", "next", "c", "useState", "initial", "comp", "useCurrentComponent", "key", "setterName", "next", "value", "newValue", "hookIndex", "setValue", "useEffect", "effect", "deps", "comp", "useCurrentComponent", "hookIndex", "prevDeps", "d", "i", "cleanup"]
}
