{
  "version": 3,
  "sources": ["../lib/hooks/index.js", "../lib/reactive-core.js", "../lib/hooks/useFetch.js", "../lib/hooks/useContext.js", "../lib/hooks/useState.js", "../lib/hooks/useEffect.js", "../lib/utils/context.js", "../lib/hooks/useEmit.js", "../lib/hooks/useEvent.js", "../lib/hooks/useEvents.js"],
  "sourcesContent": ["export * from \"./useFetch.js\";\r\nexport * from \"./useContext.js\";\r\nexport * from \"./useState.js\";\r\nexport * from \"./useEffect.js\";\r\nexport * from \"./useEmit.js\";\r\nexport * from \"./useEvent.js\";\r\nexport * from \"./useEvents.js\";\r\n", "import diffHTML from \"./diffHTML.js\";\r\nimport bindEvents from \"./bindEvents.js\";\r\nimport getRef from \"./get-refs.js\";\r\nimport hydrateSlots from \"./hydrateSlots.js\";\r\nimport hydrateActions from \"./hydrateActions.js\";\r\nimport { runHook } from \"./reactive-core-helpers/runHook.js\";\r\nimport { runBeforeHook } from \"./reactive-core-helpers/runBeforeHook.js\";\r\nimport { syncInstanceToAPI } from \"./reactive-core-helpers/syncInstanceToAPI.js\";\r\nlet id = 1;\r\n\r\nexport const __VERSION__ = process.env.APP_VERSION || \"\";\r\n\r\nexport const globalComponentRegistry = new Map();\r\n\r\nexport function registerComponent(instance) {\r\n  if (!instance._id) return;\r\n  //   instance._id = `comp-${Math.random().toString(36).slice(2)}`;\r\n  globalComponentRegistry.set(instance._id, instance);\r\n}\r\n\r\nexport function unregisterComponent(instance) {\r\n  if (instance._id) globalComponentRegistry.delete(instance._id);\r\n}\r\n\r\nexport function getComponentById(id) {\r\n  return globalComponentRegistry.get(id);\r\n}\r\n\r\nlet currentComponent = null;\r\n\r\n// --- INTERNAL: clone a component from a frozen template (no mount yet) ---\r\nfunction __cloneFromTemplate(sourceComp, initialProps = {}) {\r\n  const tpl = sourceComp._frozenTemplate;\r\n  // Rebuild a fresh callable component from the same render + options\r\n  // merge these initialProps with the instance props\r\n  const clone = createComponent(tpl.renderFn, tpl.options);\r\n  // Stash initial props to apply on first mount/update\r\n  clone._initialProps = initialProps;\r\n  // clone.props = { ...initialProps };\r\n  // For debugging / safety, remember who produced this clone\r\n  clone._templateSource = sourceComp;\r\n\r\n  // console.log(\"Cloning component:\", clone.props);\r\n\r\n  return clone;\r\n}\r\n\r\nexport function createComponent(arg1, arg2 = {}) {\r\n  let renderFn;\r\n  let options = {};\r\n\r\n  const ftype = typeof arg1;\r\n  // Detect object-style usage\r\n  if (\r\n    ftype === \"object\" &&\r\n    ftype !== \"function\" &&\r\n    arg1 !== null &&\r\n    !Array.isArray(arg1)\r\n  ) {\r\n    renderFn = arg1.render;\r\n    options = { ...arg1 };\r\n    delete options.render; // avoid duplicate\r\n  } else {\r\n    // Old signature: createComponent(renderFn, options)\r\n    renderFn = arg1;\r\n    options = arg2 || {};\r\n  }\r\n\r\n  let {\r\n    state: initialState = {},\r\n    on = {},\r\n    slots = {},\r\n    onMount,\r\n    onUnmount,\r\n    onBeforeMount,\r\n    onBeforeUnmount,\r\n    onUpdate,\r\n    onBeforeRender,\r\n    ...custom\r\n  } = options;\r\n\r\n  let el = null;\r\n  let mounted = false;\r\n  let props = {};\r\n  let prevProps = {};\r\n  let scheduledRenderProps = null;\r\n  let onBeforeMountDone = false;\r\n  let boundEvents = [];\r\n  let state = initialState;\r\n  let _cachedNode = null;\r\n  let _renderedNull = false;\r\n  const originalInitialState = { ...initialState };\r\n  let renderScheduled = false;\r\n\r\n  const setState = (next) => {\r\n    state = typeof next === \"function\" ? next(state) : { ...state, ...next };\r\n    if (!renderScheduled) {\r\n      renderScheduled = true;\r\n      scheduledRenderProps = { ...props };\r\n      queueMicrotask(() => {\r\n        renderScheduled = false;\r\n        componentFn(scheduledRenderProps);\r\n        scheduledRenderProps = null;\r\n      });\r\n    }\r\n  };\r\n\r\n  const api = {\r\n    refs: {},\r\n    on() {},\r\n    setState,\r\n    props,\r\n    _childCallCache: {}, // per-parent render-order child instance cache\r\n    _childCallIndex: 0, // increments every time a child() is called during this render\r\n    isMounted: () => mounted,\r\n    _renderIndex: 0,\r\n    _mountedChildren: [],\r\n    _unmountCbs: [],\r\n    _mountCbs: [],\r\n    _beforeMountCbs: [],\r\n    _updateCbs: [],\r\n    _beforeUnmountCbs: [],\r\n    _beforeRenderCbs: [],\r\n\r\n    // runtime-attachable mount\r\n    onMount(fn) {\r\n      if (typeof fn === \"function\") this._mountCbs.push(fn);\r\n    },\r\n    // runtime-attachable cleanup\r\n    onUnmount(fn) {\r\n      if (typeof fn === \"function\") this._unmountCbs.push(fn);\r\n    },\r\n    // runtime-attachable before mount\r\n    onBeforeMount(fn) {\r\n      if (typeof fn === \"function\") this._beforeMountCbs.push(fn);\r\n    },\r\n    onBeforeUnmount(fn) {\r\n      if (typeof fn === \"function\") this._beforeUnmountCbs.push(fn);\r\n    },\r\n    // runtime-attachable before mount\r\n    onUpdate(fn) {\r\n      if (typeof fn === \"function\") this._updateCbs.push(fn);\r\n    },\r\n    // runtime-attachable before html processing post renderFn call\r\n    onBeforeRender(fn) {\r\n      if (typeof fn === \"function\") this._beforeRenderCbs.push(fn);\r\n    },\r\n\r\n    addEvent(key, handler) {\r\n      if (!this.on[key]) this.on[key] = handler;\r\n    },\r\n\r\n    mount(targetOrSelector, initialProps = {}) {\r\n      if (mounted || onBeforeMountDone) {\r\n        //  console.log(\"Component already mounted or mounting in progress\", componentFn._id);\r\n        return;\r\n      }\r\n      let target =\r\n        typeof targetOrSelector === \"string\"\r\n          ? document.querySelector(targetOrSelector)\r\n          : targetOrSelector;\r\n\r\n      if (!target) throw new Error(`No element matches: ${targetOrSelector}`);\r\n\r\n      const proceed = () => {\r\n        onBeforeMountDone = true;\r\n        el = target;\r\n        // console.log(\"Mounting component\", componentFn._id, el);\r\n        // Mark this as a component root for event isolation\r\n        el.setAttribute(\r\n          \"data-comp-root\",\r\n          componentFn._id + \"-\" + (renderFn.name || \"\")\r\n        );\r\n\r\n        props = { ...props, ...initialProps };\r\n        prevProps = { ...props };\r\n        api.props = props;\r\n\r\n        // Attach the component instance for ref lookups\r\n        el._componentInstance = componentFn;\r\n\r\n        if (props.key) {\r\n          el.setAttribute(\"data-key\", props.key);\r\n        }\r\n\r\n        componentFn(props);\r\n\r\n        // \u2705 Automatically hydrate component instances passed to props.children or props.slots\r\n        // hydrateSlots(componentFn, props, api, slots);\r\n\r\n        //bindEvents(api, el, on, api._boundEvents); // Ensure `on` from options is passed correctly\r\n\r\n        if (!_renderedNull) {\r\n          mounted = true;\r\n          //onMount?.call(componentFn);\r\n          runHook(api._mountCbs, undefined, false, componentFn);\r\n        }\r\n      };\r\n\r\n      // Execute onBeforeMount callbacks\r\n      //runHook(api._beforeMountCbs);\r\n\r\n      runBeforeHook(api._beforeMountCbs, proceed, componentFn);\r\n    },\r\n\r\n    update(input = {}) {\r\n      if (!mounted) return;\r\n      const nextProps = input.props ? input.props : input;\r\n\r\n      const newOn = nextProps.on;\r\n      if (newOn) {\r\n        Object.assign(api.on, newOn);\r\n      }\r\n\r\n      const merged = { ...props, ...nextProps };\r\n      prevProps = { ...props };\r\n      props = merged;\r\n      api.props = props;\r\n\r\n      // reset data-key if props.key changes\r\n      if (props.key !== prevProps.key) {\r\n        el.setAttribute(\"data-key\", props.key);\r\n      }\r\n\r\n      componentFn(props);\r\n    },\r\n\r\n    render(newProps = {}) {\r\n      props = { ...props, ...newProps };\r\n      api.props = props;\r\n      let phtml =\r\n        typeof renderFn === \"function\"\r\n          ? renderFn.call(componentFn, { state, setState, props, refs: api.refs })\r\n          : renderFn;\r\n\r\n      let html = runHook(api._beforeRenderCbs, phtml, false, componentFn);\r\n\r\n      if (html) {\r\n        html = new String(html);\r\n        html._id = componentFn._id;\r\n      }\r\n\r\n      syncInstanceToAPI(api, componentFn);\r\n      return html;\r\n    },\r\n\r\n    _resetInternal: () => {\r\n      api._mountedChildren.forEach((child) => {\r\n        if (child && typeof child.unmount === \"function\") {\r\n          child.unmount();\r\n        }\r\n      });\r\n      api._mountedChildren = [];\r\n      _cachedNode = null;\r\n      _renderedNull = false;\r\n      el = null; // <-- Add this line\r\n      mounted = false;\r\n      onBeforeMountDone = false;\r\n      boundEvents = [];\r\n      props = {};\r\n      prevProps = {};\r\n      state = { ...originalInitialState };\r\n    },\r\n\r\n    unmount() {\r\n      if (!mounted || !el) return;\r\n\r\n      const cleanup = () => {\r\n        if (el.firstChild) {\r\n          _cachedNode = el.firstChild.cloneNode(true);\r\n          el.removeChild(el.firstChild);\r\n        }\r\n\r\n        runHook(api._unmountCbs, undefined, true, componentFn);\r\n\r\n        boundEvents.forEach(({ node, type, listener }) => {\r\n          node.removeEventListener(type, listener);\r\n        });\r\n        boundEvents = [];\r\n\r\n        mounted = false;\r\n        onBeforeMountDone = false;\r\n        _renderedNull = true;\r\n        // onUnmount?.call(api);\r\n\r\n        unregisterComponent(componentFn); // <-- remove from registry\r\n        if (api._resetInternal) api._resetInternal();\r\n      };\r\n\r\n      runBeforeHook(api._beforeUnmountCbs, cleanup, api);\r\n    },\r\n\r\n    get renderFn() {\r\n      return renderFn;\r\n    },\r\n    get el() {\r\n      return el;\r\n    },\r\n    get state() {\r\n      return state;\r\n    },\r\n  };\r\n\r\n  // Register option lifecycles into arrays\r\n  if (onMount) api.onMount(onMount);\r\n  if (onUnmount) api.onUnmount(onUnmount);\r\n  if (onBeforeMount) api.onBeforeMount(onBeforeMount);\r\n  if (onBeforeUnmount) api.onBeforeUnmount(onBeforeUnmount);\r\n  if (onUpdate) api.onUpdate(onUpdate);\r\n  if (onBeforeRender) api.onBeforeRender(onBeforeRender);\r\n\r\n  // overrides defaults\r\n  Object.assign(api.on, on);\r\n\r\n  api.ref = function (name) {\r\n    return getRef(this.el, name);\r\n  };\r\n\r\n  api.refs = new Proxy(\r\n    {},\r\n    {\r\n      get(_, key) {\r\n        return api.ref(key);\r\n      },\r\n    }\r\n  );\r\n\r\n  function render(currentProps) {\r\n    props = { ...api.props, ...currentProps };\r\n    api.props = props;\r\n\r\n    if (!el || el.isConnected === false) {\r\n      //console.warn(\"Component root element is not connected to the DOM, skipping render:\", componentFn._id, componentFn.renderFn())\r\n      //return;\r\n    }\r\n\r\n    const html = api.render(props);\r\n\r\n    if (html === null || html === \"\") {\r\n      if (!_renderedNull && el && el.firstChild) {\r\n        const realNode = el.firstChild;\r\n        _cachedNode = realNode.cloneNode(true);\r\n        runBeforeHook(\r\n          api._beforeUnmountCbs,\r\n          () => {\r\n            // Remove all child nodes, not just first\r\n            el.innerHTML = \"\";\r\n            boundEvents.forEach(({ node, type, listener }) => {\r\n              node.removeEventListener(type, listener);\r\n            });\r\n            boundEvents = [];\r\n            mounted = false;\r\n            _renderedNull = true;\r\n            // onUnmount?.call(api);\r\n            runHook(api._unmountCbs, undefined, true, componentFn);\r\n          },\r\n          api\r\n        );\r\n      } else {\r\n        _renderedNull = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (_renderedNull && _cachedNode) {\r\n      el.appendChild(_cachedNode);\r\n      _cachedNode = null;\r\n      _renderedNull = false;\r\n      mounted = true;\r\n      bindEvents(componentFn, el, componentFn.on, boundEvents);\r\n      // onMount?.call(api);\r\n      runHook(api._mountCbs, undefined, false, componentFn);\r\n      return;\r\n    }\r\n\r\n    diffHTML(el, html);\r\n    hydrateSlots(componentFn, props, api, slots);\r\n    hydrateActions(componentFn, el);\r\n    //    console.log(\"Rendered HTML:\", html, el === null ? \"null\" : el.outerHTML, el === componentFn.el, el.isConnected)\r\n\r\n    bindEvents(componentFn, el, componentFn.on, boundEvents);\r\n\r\n    if (mounted) {\r\n      // onUpdate.call(api, prevProps);\r\n      runHook(api._updateCbs, prevProps, false, componentFn);\r\n    }\r\n\r\n    _renderedNull = false;\r\n    return html;\r\n  }\r\n\r\n  let lastHtml = \"\";\r\n  // Create the callable component function\r\n  function componentFn(props = {}) {\r\n    // console.log(\"caller\", componentFn._fromSlotHydration, props, componentFn._id);\r\n    // if (props._fromSlotHydration) {\r\n    //   // console.log('slot hydration call, skip child logic', props);\r\n    // } else {\r\n    //   // console.log('normal call', props);\r\n    // }\r\n    // If we are inside ANOTHER component's render, this is a child call.\r\n    if (\r\n      !componentFn._fromSlotHydration &&\r\n      currentComponent &&\r\n      currentComponent !== componentFn\r\n    ) {\r\n      // Short-circuit: if called from slot hydration, just return instance\r\n\r\n      // Child call inside parent render\r\n      const parent = currentComponent;\r\n      if (parent._childCallIndex == null) parent._childCallIndex = 0;\r\n      if (!parent._childCallCache) parent._childCallCache = {};\r\n      const cacheKey = props.key != null ? props.key : parent._childCallIndex++;\r\n      let inst = parent._childCallCache[cacheKey];\r\n      if (!inst || inst._templateSource !== componentFn) {\r\n        // console.log(\"Child component detected:\", componentFn._id, currentComponent._id, props);\r\n        inst = __cloneFromTemplate(componentFn, props);\r\n        inst._prevProps = { ...props };\r\n\r\n        inst.toString = () => {\r\n          // return inst._id\r\n          return `<div data-comp=\"${inst._id}\"></div>`;\r\n        };\r\n        parent._childCallCache[cacheKey] = inst;\r\n      } else {\r\n        // console.log(\"Reusing existing child instance:\", inst._id, props, inst.isMounted());\r\n\r\n        // Always update child instance with latest props\r\n        inst._prevProps = { ...props };\r\n        inst.update(props);\r\n      }\r\n\r\n      // if props.key then add to el data-key\r\n\r\n      return inst;\r\n    }\r\n    // Normal top-level render of THIS component\r\n    currentComponent = componentFn;\r\n    componentFn._renderIndex = 0;\r\n    componentFn._childCallIndex = 0;\r\n    componentFn._prevProps = props;\r\n    // console.log('call render for', componentFn._id, props);\r\n    // Reset child call index for this render pass\r\n    lastHtml = componentFn._render(props);\r\n    currentComponent = null;\r\n    return componentFn;\r\n  }\r\n\r\n  // Add toString method to componentFn\r\n\r\n  componentFn.toString = function () {\r\n    // If we haven't produced HTML yet, emit a placeholder wrapper so the parent\r\n    // can locate and mount this instance by ID.\r\n    // But only when within a parent component\r\n    if (\r\n      !lastHtml ||\r\n      (String(lastHtml) === \"\" &&\r\n        !componentFn.isMounted() &&\r\n        currentComponent !== null &&\r\n        currentComponent._id !== componentFn._id)\r\n    ) {\r\n      return String(componentFn._id);\r\n      //return `<div data-comp=\"${componentFn._id}\"></div>`;\r\n    }\r\n    return lastHtml ? String(lastHtml) : \"\";\r\n  };\r\n\r\n  // Attach API methods\r\n  Object.assign(componentFn, api, custom);\r\n\r\n  // Dynamically attach instance-backed getters\r\n  [\"el\", \"props\", \"state\", \"setState\"].forEach((key) => {\r\n    Object.defineProperty(componentFn, key, {\r\n      get() {\r\n        return api[key];\r\n      },\r\n      enumerable: true,\r\n      configurable: false,\r\n    });\r\n  });\r\n\r\n  componentFn._render = render;\r\n  componentFn.render = api.render;\r\n  componentFn._id = id++;\r\n  componentFn.getId = () => componentFn._id;\r\n  registerComponent(componentFn); // <-- auto register\r\n\r\n  // Freeze a template of the original definition so we can clone later\r\n  componentFn._frozenTemplate = Object.freeze({\r\n    renderFn,\r\n    // use the original options shape but ensure state is not aliased\r\n    options: { ...options, state: { ...originalInitialState } },\r\n  });\r\n\r\n  return componentFn;\r\n}\r\n\r\n// Usage in composables:\r\nexport function useCurrentComponent() {\r\n  return currentComponent;\r\n}\r\n", "// useFetch.js\r\nimport { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\nexport function useFetch(url, options = {}) {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error('useFetch must be called inside a component render or lifecycle');\r\n\r\n  // Initialize component state only once per component instance\r\n  if (!comp.state || (comp.state.data === undefined && comp.state.loading === undefined && comp.state.error === undefined)) {\r\n    comp.setState({ data: null, loading: true, error: null });\r\n  }\r\n\r\n  async function run() {\r\n    comp.setState(s => ({ ...s, loading: true }));\r\n    try {\r\n      const res = await fetch(url, options);\r\n      const data = await res.json();\r\n      comp.setState({ data, error: null, loading: false });\r\n      if (comp.emit) comp.emit(\"fetch::done\", { url, data });\r\n    } catch (error) {\r\n      comp.setState({ data: null, error, loading: false });\r\n      if (comp.emit) comp.emit(\"fetch::error\", { url, error });\r\n    }\r\n  }\r\n\r\n  comp.onMount(run);\r\n  if (comp.onEmit) comp.onEmit(\"fetch::refresh\", run);\r\n\r\n  return {\r\n    get: () => ({ ...comp.state }),\r\n    subscribe: (fn) => {\r\n      // Simple subscription: call fn on update\r\n      comp.onUpdate(() => fn({ ...comp.state }));\r\n      // Return unsubscribe (not implemented here)\r\n      return () => {};\r\n    },\r\n    refresh: run\r\n  };\r\n}\r\n", "import { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\n// -------------------------\r\n// useContext\r\n// -------------------------\r\nconst globalContexts = {}; // key \u2192 { value, subs:Set }\r\n\r\nexport function useContext(key, defaultValue = {}) {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error(\"useContext() must be inside render()\");\r\n\r\n  if (!globalContexts[key]) {\r\n    globalContexts[key] = {\r\n      value: defaultValue,\r\n      subs: new Set()\r\n    };\r\n  }\r\n\r\n  const ctx = globalContexts[key];\r\n  ctx.subs.add(comp);\r\n\r\n  comp.onUnmount(() => ctx.subs.delete(comp));\r\n\r\n  const setValue = (next) => {\r\n    ctx.value =\r\n      typeof next === \"function\" ? next(ctx.value) : next;\r\n    ctx.subs.forEach(c => c.update());\r\n  };\r\n\r\n  return [ctx.value, setValue];\r\n}\r\n", "// hooks.js\r\nimport { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\n// -------------------------\r\n// useState\r\n// -------------------------\r\nexport function useState(initial) {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error(\"useState must be inside render()\");\r\n\r\n  // --- auto-setters for default state, run once ---\r\n  if (!comp._hasStateSetters) {\r\n    if (comp.state) {\r\n      Object.keys(comp.state).forEach(key => {\r\n        const setterName = \"set\" + key.charAt(0).toUpperCase() + key.slice(1);\r\n        if (!comp[setterName]) {\r\n          comp[setterName] = (next) => {\r\n            const value = comp.state[key];\r\n            const newValue = typeof next === \"function\" ? next(value) : next;\r\n            if (newValue !== value) {\r\n              comp.state[key] = newValue;\r\n              comp.update();\r\n            }\r\n          };\r\n        }\r\n      });\r\n    }\r\n    comp._hasStateSetters = true;\r\n  }\r\n // --- dynamic hook state ---\r\n  const hookIndex = comp._renderIndex++;\r\n  if (!comp._hooks) comp._hooks = [];\r\n  if (comp._hooks[hookIndex] === undefined) {\r\n    comp._hooks[hookIndex] =\r\n      typeof initial === \"function\" ? initial() : initial;\r\n  }\r\n\r\n  const setValue = (next) => {\r\n    const value = comp._hooks[hookIndex];\r\n    const newValue =\r\n      typeof next === \"function\" ? next(value) : next;\r\n    if (newValue !== value) {\r\n      comp._hooks[hookIndex] = newValue;\r\n      comp.update();\r\n    }\r\n  };\r\n\r\n  return [comp._hooks[hookIndex], setValue];\r\n}\r\n\r\n", "import { useCurrentComponent } from \"../reactive-core.js\";\r\n// -------------------------\r\n// useEffect\r\n// -------------------------\r\nexport function useEffect(effect, deps = []) {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error(\"useEffect must be inside render()\");\r\n\r\n  const hookIndex = comp._renderIndex++;\r\n  comp._hooks = comp._hooks || [];\r\n  const prevDeps = comp._hooks[hookIndex] || [];\r\n\r\n  const changed =\r\n    deps.length === 0 || deps.some((d, i) => d !== prevDeps[i]);\r\n\r\n  if (changed) {\r\n    let cleanup;\r\n    comp.onUnmount(() => cleanup && cleanup());\r\n    cleanup = effect();\r\n    comp._hooks[hookIndex] = deps;\r\n    // comp.update();\r\n  }\r\n}\r\n", "// context.js\r\n\r\n// ---------- Reusable channel map (used by global + components) ----------\r\nexport function createChannelMap() {\r\n  const channels = new Map();\r\n\r\n  return {\r\n    subscribe(eventName, fn) {\r\n      if (!channels.has(eventName)) channels.set(eventName, new Set());\r\n      const set = channels.get(eventName);\r\n      set.add(fn);\r\n      return () => set.delete(fn);\r\n    },\r\n    emit(eventName, payload) {\r\n      const set = channels.get(eventName);\r\n      if (set) for (const fn of set) fn(payload);\r\n    },\r\n    clear() {\r\n      channels.clear();\r\n    },\r\n  };\r\n}\r\n\r\n// ---------- Core reactive primitive ----------\r\nexport function createState(initial) {\r\n  let state = initial;\r\n  const subs = new Set();\r\n\r\n  function setState(next) {\r\n    if (\r\n      typeof state === \"object\" &&\r\n      state !== null &&\r\n      typeof next === \"object\" &&\r\n      next !== null &&\r\n      !Array.isArray(state) &&\r\n      !Array.isArray(next)\r\n    ) {\r\n      state = { ...state, ...next };\r\n    } else {\r\n      state = typeof next === \"function\" ? next(state) : next;\r\n    }\r\n    subs.forEach((fn) => fn(state));\r\n  }\r\n  function subscribe(fn) {\r\n    subs.add(fn);\r\n    fn(state);\r\n    return () => subs.delete(fn);\r\n  }\r\n  function get() {\r\n    return state;\r\n  }\r\n\r\n  return { get, setState, getState: get, subscribe };\r\n}\r\n\r\n// ---------- Global pub/sub (unchanged API) ----------\r\nexport const context = createChannelMap();\r\n\r\n// ---------- Shared stores (global keyed) ----------\r\nconst stores = new Map();\r\n\r\nexport function shared(key, initial = {}) {\r\n  if (!stores.has(key)) {\r\n    const state = createState(initial);\r\n    const api = {\r\n      ...state,\r\n      emit(event, payload) {\r\n        state.setState(payload);\r\n        context.emit(`${key}::${event}`, state.getState());\r\n      },\r\n      on(event, fn) {\r\n        return context.subscribe(`${key}::${event}`, fn);\r\n      },\r\n    };\r\n    stores.set(key, api);\r\n  }\r\n  return stores.get(key);\r\n}\r\nshared.clear = () => stores.clear();\r\n", "// hooks/useEmit.js\r\n\r\nimport { context, createChannelMap } from \"../utils/context.js\";\r\nimport { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\nexport function useEmit() {\r\n  const comp = useCurrentComponent();\r\n  if (!comp) throw new Error(\"useEmit must be inside render()\");\r\n\r\n  if (comp._hasEmits) return comp._emitsApi;\r\n  comp._hasEmits = true;\r\n\r\n  const localBus = createChannelMap();\r\n\r\n  const api = {\r\n    emit: (event, payload) => localBus.emit(event, payload),\r\n    onEmit: (event, fn) => {\r\n      const unsub = localBus.subscribe(event, fn);\r\n      comp.onUnmount(unsub); // auto cleanup\r\n      return unsub;\r\n    },\r\n    emitGlobal: (event, payload) => context.emit(event, payload),\r\n    onEmitGlobal: (event, fn) => {\r\n      const unsub = context.subscribe(event, fn);\r\n      comp.onUnmount(unsub);\r\n      return unsub;\r\n    },\r\n  };\r\n\r\n  Object.assign(comp, api);\r\n  comp._emitsApi = api;\r\n\r\n  //useContextListeners(comp, comp.on);\r\n\r\n  comp.onBeforeRender(function () {\r\n    // console.log(\"Component render called:\", Object.keys(comp.on));\r\n    useContextListeners(comp, comp.on);\r\n  });\r\n\r\n  // cleanup hook\r\n  comp.onUnmount(() => {\r\n    localBus.clear();\r\n  });\r\n\r\n  return api;\r\n}\r\n\r\n// hooks/useContextListeners.js\r\n\r\nfunction useContextListeners(comp, on = {}) {\r\n  let contextUnsubs = [];\r\n  Object.entries(on).forEach(([key, handler]) => {\r\n    // console.log(\"Registering context event:\", key);\r\n    if (key.includes(\"::\")) {\r\n      const bound = handler.bind(comp);\r\n      const unsub = context.subscribe(key, bound);\r\n      contextUnsubs.push(unsub);\r\n    }\r\n    // else if it doesn't include any spaces * or : we can treat as a local listener\r\n    else if (!key.includes(\" \") && !key.includes(\"*\") && !key.includes(\":\")) {\r\n      // console.log(\"Registering local event:\", key);\r\n      comp.onEmit(key, handler.bind(comp));\r\n    }\r\n  });\r\n\r\n  comp.onUnmount(() => {\r\n    contextUnsubs.forEach((unsub) => unsub());\r\n    contextUnsubs = [];\r\n  });\r\n}\r\n", "import { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\nexport function useEvent() {\r\n  const component = useCurrentComponent();\r\n  if (!component) throw new Error(\"useEvent must be inside render()\");\r\n  // run once per component\r\n  if (component._eventApi) component._eventApi;\r\n\r\n  function makeChainable(refId) {\r\n    const api = {\r\n      on(event, handler) {\r\n        component.addEvent(`${event} [data-ref=${refId}]`, handler);\r\n        return api; // allow chaining\r\n      },\r\n      onClick(fn) {\r\n        return this.on(\"click\", fn);\r\n      },\r\n      onBlur(fn) {\r\n        return this.on(\"blur\", fn);\r\n      },\r\n      onInput(fn) {\r\n        return this.on(\"input\", fn);\r\n      },\r\n      onChange(fn) {\r\n        return this.on(\"change\", fn);\r\n      },\r\n      onFocus(fn) {\r\n        return this.on(\"focus\", fn);\r\n      },\r\n      onSubmit(fn) {\r\n        return this.on(\"submit\", fn);\r\n      },\r\n      toString() {\r\n        return `data-ref=\"${refId}\"`;\r\n      },\r\n    };\r\n    return api;\r\n  }\r\n\r\n  function makeSingle(event) {\r\n    return (handler) => {\r\n      const refId = `h${component._renderIndex++}`;\r\n      component.addEvent(`${event} [data-ref=${refId}]`, handler);\r\n      return makeChainable(refId); // return chainable object\r\n    };\r\n  }\r\n\r\n  const api = {\r\n    onClick: makeSingle(\"click\"),\r\n    onBlur: makeSingle(\"blur\"),\r\n    onInput: makeSingle(\"input\"),\r\n    onChange: makeSingle(\"change\"),\r\n    onFocus: makeSingle(\"focus\"),\r\n    onSubmit: makeSingle(\"submit\"),\r\n    on: (event, fn) => makeSingle(event)(fn),\r\n  };\r\n\r\n  const prev = { ...component.on };\r\n  component.prototype.on = api.on;\r\n  Object.assign(component.on, prev);\r\n\r\n  component._eventApi = api;\r\n\r\n  return api;\r\n}\r\n", "import { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\nexport function useEvents() {\r\n  const component = useCurrentComponent();\r\n  if (!component) throw new Error(\"useEvent must be inside render()\");\r\n  // run once per component\r\n  if (component._events) return;\r\n\r\n  function mergeDataRefs(html) {\r\n    return html.replace(\r\n      /<([a-zA-Z0-9-]+)([^>]*?)>/gs, // match whole tag (multiline + greedy safe)\r\n      (fullMatch, tagName, attrs) => {\r\n        // collect all data-ref=\"...\" values in this tag\r\n        const refs = [...attrs.matchAll(/data-ref=\"([^\"]+)\"/g)].map(\r\n          (m) => m[1]\r\n        );\r\n\r\n        if (refs.length <= 1) {\r\n          // nothing to merge\r\n          return fullMatch;\r\n        }\r\n\r\n        // collapse them into one space-separated value\r\n        const merged = `data-ref=\"${refs.join(\" \")}\"`;\r\n\r\n        // strip all existing data-ref=\"...\" from attrs\r\n        let cleanedAttrs = attrs.replace(/\\s*data-ref=\"[^\"]*\"/g, \"\");\r\n\r\n        // rebuild tag with merged data-ref inserted once (at start of attrs for consistency)\r\n        return `<${tagName} ${merged}${cleanedAttrs}>`;\r\n      }\r\n    );\r\n  }\r\n\r\n  component.onBeforeRender(mergeDataRefs);\r\n\r\n  const prev = { ...component.on };\r\n\r\n  component.on = function useEventsHook(event, handler) {\r\n    if (event && handler) {\r\n      // const id = `h${component._renderIndex++}`;\r\n      component.addEvent(event, handler);\r\n      // return `data-ref=\"${id}\"`;\r\n    }\r\n  };\r\n\r\n  Object.assign(component.on, prev);\r\n\r\n  component._events = 1;\r\n\r\n  function makeSingle(event) {\r\n    return (handler) => {\r\n      const refId = `h${component._renderIndex++}`;\r\n      component.addEvent(`${event} [data-ref~=${refId}]`, handler);\r\n      return `data-ref=\"${refId}\"`;\r\n    };\r\n  }\r\n\r\n  return { onClick: makeSingle(\"click\") };\r\n}\r\n"],
  "mappings": "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",
  "names": ["hooks_exports", "__export", "useContext", "useEffect", "useEmit", "useEvent", "useEvents", "useFetch", "useState", "currentComponent", "useCurrentComponent", "currentComponent", "useFetch", "url", "options", "comp", "useCurrentComponent", "run", "s", "data", "error", "fn", "globalContexts", "useContext", "key", "defaultValue", "comp", "useCurrentComponent", "ctx", "setValue", "next", "c", "useState", "initial", "comp", "useCurrentComponent", "key", "setterName", "next", "value", "newValue", "hookIndex", "setValue", "useEffect", "effect", "deps", "comp", "useCurrentComponent", "hookIndex", "prevDeps", "d", "cleanup", "createChannelMap", "channels", "eventName", "fn", "set", "payload", "createState", "initial", "state", "subs", "setState", "next", "subscribe", "get", "context", "stores", "shared", "key", "api", "event", "useEmit", "comp", "useCurrentComponent", "localBus", "createChannelMap", "api", "event", "payload", "fn", "unsub", "context", "useContextListeners", "on", "contextUnsubs", "key", "handler", "bound", "useEvent", "component", "useCurrentComponent", "makeChainable", "refId", "api", "event", "handler", "fn", "makeSingle", "prev", "useEvents", "component", "useCurrentComponent", "mergeDataRefs", "html", "fullMatch", "tagName", "attrs", "refs", "m", "merged", "cleanedAttrs", "prev", "event", "handler", "makeSingle", "refId"]
}
