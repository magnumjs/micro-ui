{
  "version": 3,
  "sources": ["../lib/compose/context.js", "../lib/reactive-core.js", "../lib/compose/reactive-composables.js", "../lib/hooks/useFetch.js"],
  "sourcesContent": ["// context.js\r\n\r\n// ---------- Reusable channel map (used by global + components) ----------\r\nexport function createChannelMap() {\r\n  const channels = new Map();\r\n\r\n  return {\r\n    subscribe(eventName, fn) {\r\n      if (!channels.has(eventName)) channels.set(eventName, new Set());\r\n      const set = channels.get(eventName);\r\n      set.add(fn);\r\n      return () => set.delete(fn);\r\n    },\r\n    emit(eventName, payload) {\r\n      const set = channels.get(eventName);\r\n      if (set) for (const fn of set) fn(payload);\r\n    },\r\n    clear() {\r\n      channels.clear();\r\n    },\r\n  };\r\n}\r\n\r\n// ---------- Core reactive primitive ----------\r\nexport function createState(initial) {\r\n  let state = initial;\r\n  const subs = new Set();\r\n\r\n  function setState(next) {\r\n    if (\r\n      typeof state === \"object\" &&\r\n      state !== null &&\r\n      typeof next === \"object\" &&\r\n      next !== null &&\r\n      !Array.isArray(state) &&\r\n      !Array.isArray(next)\r\n    ) {\r\n      state = { ...state, ...next };\r\n    } else {\r\n      state = typeof next === \"function\" ? next(state) : next;\r\n    }\r\n    subs.forEach((fn) => fn(state));\r\n  }\r\n  function subscribe(fn) {\r\n    subs.add(fn);\r\n    fn(state);\r\n    return () => subs.delete(fn);\r\n  }\r\n  function get() {\r\n    return state;\r\n  }\r\n\r\n  return { get, setState, getState: get, subscribe };\r\n}\r\n\r\n// ---------- Global pub/sub (unchanged API) ----------\r\nexport const context = createChannelMap();\r\n\r\n// ---------- Shared stores (global keyed) ----------\r\nconst stores = new Map();\r\n\r\nexport function shared(key, initial = {}) {\r\n  if (!stores.has(key)) {\r\n    const state = createState(initial);\r\n    const api = {\r\n      ...state,\r\n      emit(event, payload) {\r\n        state.setState(payload);\r\n        context.emit(`${key}::${event}`, state.getState());\r\n      },\r\n      on(event, fn) {\r\n        return context.subscribe(`${key}::${event}`, fn);\r\n      },\r\n    };\r\n    stores.set(key, api);\r\n  }\r\n  return stores.get(key);\r\n}\r\nshared.clear = () => stores.clear();\r\n", "import diffHTML from \"./diffHTML.js\";\r\nimport bindEvents from \"./bindEvents.js\";\r\nimport { context, createChannelMap } from \"./compose/context.js\";\r\nimport getRef from \"./get-refs.js\";\r\nimport hydrateSlots from \"./hydrateSlots.js\";\r\nimport hydrateActions from \"./hydrateActions.js\";\r\nimport { runHook } from \"./reactive-core-helpers/runHook.js\";\r\nimport { runBeforeHook } from \"./reactive-core-helpers/runBeforeHook.js\";\r\nimport { syncInstanceToAPI } from \"./reactive-core-helpers/syncInstanceToAPI.js\";\r\nlet id = 1;\r\n\r\nexport const __VERSION__ = process.env.APP_VERSION || \"\";\r\n\r\nexport const globalComponentRegistry = new Map();\r\n\r\nexport function registerComponent(instance) {\r\n   if (!instance._id) return\r\n  //   instance._id = `comp-${Math.random().toString(36).slice(2)}`;\r\n  globalComponentRegistry.set(instance._id, instance);\r\n}\r\n\r\nexport function unregisterComponent(instance) {\r\n  if (instance._id) globalComponentRegistry.delete(instance._id);\r\n}\r\n\r\nexport function getComponentById(id) {\r\n  return globalComponentRegistry.get(id);\r\n}\r\n\r\nlet currentComponent = null;\r\n\r\n// --- INTERNAL: clone a component from a frozen template (no mount yet) ---\r\nfunction __cloneFromTemplate(sourceComp, initialProps = {}) {\r\n  const tpl = sourceComp._frozenTemplate;\r\n  // Rebuild a fresh callable component from the same render + options\r\n  // merge these initialProps with the instance props\r\n  const clone = createComponent(tpl.renderFn, tpl.options);\r\n  // Stash initial props to apply on first mount/update\r\n  clone._initialProps = initialProps;\r\n  // clone.props = { ...initialProps };\r\n  // For debugging / safety, remember who produced this clone\r\n  clone._templateSource = sourceComp;\r\n\r\n  // console.log(\"Cloning component:\", clone.props);\r\n\r\n  return clone;\r\n}\r\n\r\nexport function createComponent(arg1, arg2 = {}) {\r\n  let renderFn;\r\n  let options = {};\r\n\r\n  const ftype = typeof arg1;\r\n  // Detect object-style usage\r\n  if (\r\n    ftype === \"object\" &&\r\n    ftype !== \"function\" &&\r\n    arg1 !== null &&\r\n    !Array.isArray(arg1)\r\n  ) {\r\n    renderFn = arg1.render;\r\n    options = { ...arg1 };\r\n    delete options.render; // avoid duplicate\r\n  } else {\r\n    // Old signature: createComponent(renderFn, options)\r\n    renderFn = arg1;\r\n    options = arg2 || {};\r\n  }\r\n\r\n  let {\r\n    state: initialState = {},\r\n    on = {},\r\n    slots = {},\r\n    onMount,\r\n    onUnmount,\r\n    onBeforeMount,\r\n    onBeforeUnmount,\r\n    onUpdate,\r\n    ...custom\r\n  } = options;\r\n\r\n  let el = null;\r\n  let mounted = false;\r\n  let props = {};\r\n  let prevProps = {};\r\n  let scheduledRenderProps = null;\r\n  let onBeforeMountDone = false;\r\n  let boundEvents = [];\r\n  let state = initialState;\r\n  let _cachedNode = null;\r\n  let _renderedNull = false;\r\n  const originalInitialState = { ...initialState };\r\n  let renderScheduled = false;\r\n  let contextUnsubs = [];\r\n  const localBus = createChannelMap();\r\n\r\n  const setState = (next) => {\r\n    state = typeof next === \"function\" ? next(state) : { ...state, ...next };\r\n    if (!renderScheduled) {\r\n      renderScheduled = true;\r\n      scheduledRenderProps = { ...props };\r\n      queueMicrotask(() => {\r\n        renderScheduled = false;\r\n        componentFn(scheduledRenderProps);\r\n        scheduledRenderProps = null;\r\n      });\r\n    }\r\n  };\r\n\r\n  const api = {\r\n    refs: {},\r\n    on,\r\n    setState,\r\n    props,\r\n    _childCallCache: {}, // per-parent render-order child instance cache\r\n    _childCallIndex: 0, // increments every time a child() is called during this render\r\n    isMounted: () => mounted,\r\n    _renderIndex: 0,\r\n    _mountedChildren: [],\r\n    _unmountCbs: [],\r\n    _mountCbs: [],\r\n    _beforeMountCbs: [],\r\n    _updateCbs: [],\r\n    _beforeUnmountCbs: [],\r\n\r\n    // runtime-attachable mount\r\n    onMount(fn) {\r\n      if (typeof fn === \"function\") this._mountCbs.push(fn);\r\n    },\r\n    // runtime-attachable cleanup\r\n    onUnmount(fn) {\r\n      if (typeof fn === \"function\") this._unmountCbs.push(fn);\r\n    },\r\n    // runtime-attachable before mount\r\n    onBeforeMount(fn) {\r\n      if (typeof fn === \"function\") this._beforeMountCbs.push(fn);\r\n    },\r\n    onBeforeUnmount(fn) {\r\n      if (typeof fn === \"function\") this._beforeUnmountCbs.push(fn);\r\n    },\r\n    // runtime-attachable before mount\r\n    onUpdate(fn) {\r\n      if (typeof fn === \"function\") this._updateCbs.push(fn);\r\n    },\r\n\r\n    // local (component-scoped) events\r\n    emit(event, payload) {\r\n      localBus.emit(event, payload);\r\n    },\r\n    onEmit(event, fn) {\r\n      const unsub = localBus.subscribe(event, fn);\r\n      this.onUnmount(unsub);\r\n      return unsub;\r\n    },\r\n\r\n    // global events passthrough (optional helpers)\r\n    emitGlobal(event, payload) {\r\n      context.emit(event, payload);\r\n    },\r\n    onEmitGlobal(event, fn) {\r\n      const unsub = context.subscribe(event, fn);\r\n      this.onUnmount(unsub);\r\n      return unsub;\r\n    },\r\n\r\n    addEvent(key, handler) {\r\n      on[key] = handler;\r\n    },\r\n\r\n    mount(targetOrSelector, initialProps = {}) {\r\n      if (mounted || onBeforeMountDone) {\r\n        //  console.log(\"Component already mounted or mounting in progress\", componentFn._id);\r\n        return;\r\n      }\r\n      let target =\r\n        typeof targetOrSelector === \"string\"\r\n          ? document.querySelector(targetOrSelector)\r\n          : targetOrSelector;\r\n\r\n      if (!target) throw new Error(`No element matches: ${targetOrSelector}`);\r\n\r\n      const proceed = () => {\r\n        onBeforeMountDone = true;\r\n        el = target;\r\n        // console.log(\"Mounting component\", componentFn._id, el);\r\n        // Mark this as a component root for event isolation\r\n        el.setAttribute(\r\n          \"data-comp-root\",\r\n          componentFn._id + \"-\" + (renderFn.name || \"\")\r\n        );\r\n\r\n        props = { ...props, ...initialProps };\r\n        prevProps = { ...props };\r\n        api.props = props;\r\n\r\n\r\n        if (props.key) {\r\n          el.setAttribute(\"data-key\", props.key);\r\n        }\r\n\r\n        componentFn(props);\r\n\r\n        // \u2705 Automatically hydrate component instances passed to props.children or props.slots\r\n        // hydrateSlots(componentFn, props, api, slots);\r\n\r\n        //bindEvents(api, el, on, api._boundEvents); // Ensure `on` from options is passed correctly\r\n\r\n        if (!_renderedNull) {\r\n          mounted = true;\r\n          //onMount?.call(componentFn);\r\n          runHook(api._mountCbs, undefined, false, componentFn);\r\n          setupContextListeners();\r\n        }\r\n      };\r\n\r\n      // Execute onBeforeMount callbacks\r\n      //runHook(api._beforeMountCbs);\r\n\r\n      runBeforeHook(api._beforeMountCbs, proceed, componentFn);\r\n    },\r\n\r\n    update(input = {}) {\r\n      if (!mounted) return;\r\n      const nextProps = input.props ? input.props : input;\r\n\r\n      const newOn = nextProps.on;\r\n      if (newOn && newOn !== on) {\r\n        on = newOn;\r\n      }\r\n\r\n      const merged = { ...props, ...nextProps };\r\n      prevProps = { ...props };\r\n      props = merged;\r\n      api.props = props;\r\n\r\n      // reset data-key if props.key changes\r\n      if (props.key !== prevProps.key) {\r\n        el.setAttribute(\"data-key\", props.key);\r\n      }\r\n\r\n      componentFn(props);\r\n    },\r\n\r\n    render(newProps = {}) {\r\n      props = { ...props, ...newProps };\r\n      api.props = props;\r\n      let html =\r\n        typeof renderFn === \"function\"\r\n          ? renderFn.call(api, { state, setState, props, refs: api.refs })\r\n          : renderFn;\r\n\r\n      if (html) {\r\n        html = new String(html);\r\n        html._id = componentFn._id;\r\n      }\r\n\r\n      syncInstanceToAPI(api, componentFn);\r\n      return html;\r\n    },\r\n\r\n    _resetInternal: () => {\r\n      api._mountedChildren.forEach((child) => {\r\n        if (child && typeof child.unmount === \"function\") {\r\n          child.unmount();\r\n        }\r\n      });\r\n      api._mountedChildren = [];\r\n      _cachedNode = null;\r\n      _renderedNull = false;\r\n      el = null; // <-- Add this line\r\n      mounted = false;\r\n      onBeforeMountDone = false;\r\n      boundEvents = [];\r\n      props = {};\r\n      prevProps = {};\r\n      state = { ...originalInitialState };\r\n    },\r\n\r\n    unmount() {\r\n      if (!mounted || !el) return;\r\n\r\n      const cleanup = () => {\r\n        if (el.firstChild) {\r\n          _cachedNode = el.firstChild.cloneNode(true);\r\n          el.removeChild(el.firstChild);\r\n        }\r\n\r\n        runHook(api._unmountCbs, undefined, true, componentFn);\r\n\r\n        localBus.clear(); // clear local listeners\r\n\r\n        boundEvents.forEach(({ node, type, listener }) => {\r\n          node.removeEventListener(type, listener);\r\n        });\r\n        boundEvents = [];\r\n\r\n        contextUnsubs.forEach((unsub) => unsub());\r\n        contextUnsubs = [];\r\n\r\n        mounted = false;\r\n        onBeforeMountDone = false;\r\n        _renderedNull = true;\r\n        // onUnmount?.call(api);\r\n\r\n        unregisterComponent(componentFn); // <-- remove from registry\r\n        if (api._resetInternal) api._resetInternal();\r\n      };\r\n\r\n      runBeforeHook(api._beforeUnmountCbs, cleanup, api);\r\n    },\r\n\r\n    get renderFn() {\r\n      return renderFn;\r\n    },\r\n    get el() {\r\n      return el;\r\n    },\r\n    get state() {\r\n      return state;\r\n    },\r\n  };\r\n\r\n  // Register option lifecycles into arrays\r\n  if (onMount) api.onMount(onMount);\r\n  if (onUnmount) api.onUnmount(onUnmount);\r\n  if (onBeforeMount) api.onBeforeMount(onBeforeMount);\r\n  if (onBeforeUnmount) api.onBeforeUnmount(onBeforeUnmount);\r\n  if (onUpdate) api.onUpdate(onUpdate);\r\n\r\n  api.ref = function (name) {\r\n    return getRef(this.el, name);\r\n  };\r\n\r\n  api.refs = new Proxy(\r\n    {},\r\n    {\r\n      get(_, key) {\r\n        return api.ref(key);\r\n      },\r\n    }\r\n  );\r\n\r\n  //TODO: is this needed or even used?\r\n  // api.action = function (e) {\r\n  //   return e.target.closest(\"[data-action]\")?.dataset.action || null;\r\n  // };\r\n\r\n  function setupContextListeners() {\r\n    contextUnsubs = [];\r\n    Object.entries(on).forEach(([key, handler]) => {\r\n      if (key.includes(\"::\")) {\r\n        const bound = handler.bind(api);\r\n        const unsub = context.subscribe(key, bound);\r\n        contextUnsubs.push(unsub);\r\n      }\r\n    });\r\n  }\r\n\r\n  function render(currentProps) {\r\n    props = { ...api.props, ...currentProps };\r\n    api.props = props;\r\n\r\n    if (!el || el.isConnected === false) {\r\n      //console.warn(\"Component root element is not connected to the DOM, skipping render:\", componentFn._id, componentFn.renderFn())\r\n      //return;\r\n    }\r\n\r\n    const html = api.render(props);\r\n\r\n    if (html === null || html === \"\") {\r\n      if (!_renderedNull && el && el.firstChild) {\r\n        const realNode = el.firstChild;\r\n        _cachedNode = realNode.cloneNode(true);\r\n        runBeforeHook(\r\n          api._beforeUnmountCbs,\r\n          () => {\r\n            // Remove all child nodes, not just first\r\n            el.innerHTML = \"\";\r\n            boundEvents.forEach(({ node, type, listener }) => {\r\n              node.removeEventListener(type, listener);\r\n            });\r\n            boundEvents = [];\r\n            mounted = false;\r\n            _renderedNull = true;\r\n            // onUnmount?.call(api);\r\n            runHook(api._unmountCbs, undefined, true, componentFn);\r\n          },\r\n          api\r\n        );\r\n      } else {\r\n        _renderedNull = true;\r\n      }\r\n      return;\r\n    }\r\n\r\n    if (_renderedNull && _cachedNode) {\r\n      el.appendChild(_cachedNode);\r\n      _cachedNode = null;\r\n      _renderedNull = false;\r\n      mounted = true;\r\n      bindEvents(api, el, on, boundEvents);\r\n      // onMount?.call(api);\r\n      runHook(api._mountCbs, undefined, false, componentFn);\r\n      return;\r\n    }\r\n\r\n    diffHTML(el, html);\r\n    hydrateSlots(componentFn, props, api, slots);\r\n    hydrateActions(componentFn, el);\r\n    //    console.log(\"Rendered HTML:\", html, el === null ? \"null\" : el.outerHTML, el === componentFn.el, el.isConnected)\r\n\r\n    bindEvents(api, el, on, boundEvents);\r\n\r\n    if (mounted) {\r\n      // onUpdate.call(api, prevProps);\r\n      runHook(api._updateCbs, prevProps, false, componentFn);\r\n    }\r\n\r\n    _renderedNull = false;\r\n    return html;\r\n  }\r\n\r\n  let lastHtml = \"\";\r\n  // Create the callable component function\r\n  function componentFn(props = {}) {\r\n    // console.log(\"caller\", componentFn._fromSlotHydration, props, componentFn._id);\r\n    // if (props._fromSlotHydration) {\r\n    //   // console.log('slot hydration call, skip child logic', props);\r\n    // } else {\r\n    //   // console.log('normal call', props);\r\n    // }\r\n    // If we are inside ANOTHER component's render, this is a child call.\r\n    if (\r\n      !componentFn._fromSlotHydration &&\r\n      currentComponent &&\r\n      currentComponent !== componentFn\r\n    ) {\r\n      // Short-circuit: if called from slot hydration, just return instance\r\n\r\n      // Child call inside parent render\r\n      const parent = currentComponent;\r\n      if (parent._childCallIndex == null) parent._childCallIndex = 0;\r\n      if (!parent._childCallCache) parent._childCallCache = {};\r\n      const idx = parent._childCallIndex++;\r\n      let inst = parent._childCallCache[idx];\r\n      if (!inst || inst._templateSource !== componentFn) {\r\n        // console.log(\"Child component detected:\", componentFn._id, currentComponent._id, props);\r\n        inst = __cloneFromTemplate(componentFn, props);\r\n        inst._prevProps = { ...props };\r\n\r\n        inst.toString = () =>  {\r\n         // return inst._id\r\n          return `<div data-comp=\"${inst._id}\"></div>`;\r\n        }\r\n        parent._childCallCache[idx] = inst;\r\n      } else {\r\n        // console.log(\"Reusing existing child instance:\", inst._id, props, inst.isMounted());\r\n\r\n        // Always update child instance with latest props\r\n        inst._prevProps = { ...props };\r\n        inst.update(props);\r\n      }\r\n\r\n      // if props.key then add to el data-key\r\n\r\n      return inst;\r\n    }\r\n    // Normal top-level render of THIS component\r\n    currentComponent = componentFn;\r\n    componentFn._renderIndex = 0;\r\n    componentFn._childCallIndex = 0;\r\n    componentFn._prevProps = props;\r\n    // console.log('call render for', componentFn._id, props);\r\n    // Reset child call index for this render pass\r\n    lastHtml = componentFn._render(props);\r\n    currentComponent = null;\r\n    return componentFn;\r\n  }\r\n\r\n  // Add toString method to componentFn\r\n\r\n  componentFn.toString = function () {\r\n    // If we haven't produced HTML yet, emit a placeholder wrapper so the parent\r\n    // can locate and mount this instance by ID.\r\n    if (!lastHtml || String(lastHtml) === \"\" && !componentFn.isMounted() && currentComponent) {\r\n     return componentFn._id\r\n      //return `<div data-comp=\"${componentFn._id}\"></div>`;\r\n    }\r\n    return lastHtml ? String(lastHtml) : \"\";\r\n  };\r\n\r\n  // Attach API methods\r\n  Object.assign(componentFn, api, custom);\r\n\r\n  // Dynamically attach instance-backed getters\r\n  [\"el\", \"props\", \"state\", \"setState\"].forEach((key) => {\r\n    Object.defineProperty(componentFn, key, {\r\n      get() {\r\n        return api[key];\r\n      },\r\n      enumerable: true,\r\n      configurable: false,\r\n    });\r\n  });\r\n\r\n  componentFn._render = render;\r\n  componentFn.render = api.render;\r\n  componentFn._id = id++;\r\n  componentFn.getId = () => componentFn._id;\r\n  registerComponent(componentFn); // <-- auto register\r\n\r\n  // Freeze a template of the original definition so we can clone later\r\n  componentFn._frozenTemplate = Object.freeze({\r\n    renderFn,\r\n    // use the original options shape but ensure state is not aliased\r\n    options: { ...options, state: { ...originalInitialState } },\r\n  });\r\n\r\n  return componentFn;\r\n}\r\n\r\n// Moved to reactive-core-helpers/renderList.js\r\nimport { renderList } from \"./reactive-core-helpers/renderList.js\";\r\nexport { renderList };\r\n\r\n// Usage in composables:\r\nexport function useCurrentComponent() {\r\n  return currentComponent;\r\n}\r\n", "// reactive-composables.js\r\nimport { createState, shared as sharedStore } from \"./context.js\";\r\nimport { useCurrentComponent } from \"../reactive-core.js\";\r\n\r\n// 1) Local state \u2014 returns [get, set, subscribe]\r\nexport function useState(initial) {\r\n  const state = createState(initial);\r\n  const get = () => state.get();\r\n  const set = (next) => state.setState(next);\r\n\r\n  const comp = useCurrentComponent();\r\n  if (comp) {\r\n    const unsub = state.subscribe(() => comp.update());\r\n    comp.onUnmount(unsub);\r\n  }\r\n  return [get, set, state.subscribe];\r\n}\r\n\r\n// 2) Shared (global keyed) \u2014 auto rerender in component\r\nexport function shared(key, initial = {}) {\r\n  const store = sharedStore(key, initial);\r\n  const comp = useCurrentComponent();\r\n  if (comp) {\r\n    const unsub = store.subscribe(() => comp.update());\r\n    comp.onUnmount(unsub);\r\n  }\r\n  return store;\r\n}\r\n\r\n// 3) Computed derived values with optional deps for auto-recompute\r\n//    deps: array of subscribe-able things or subscribe functions\r\nexport function computed(getter, deps = []) {\r\n  let cached = getter();\r\n  const subs = new Set();\r\n\r\n  function evaluate() {\r\n    const v = getter();\r\n    if (v !== cached) {\r\n      cached = v;\r\n      subs.forEach(fn => fn(cached));\r\n    }\r\n  }\r\n\r\n  // Auto re-evaluate when deps change\r\n  const comp = useCurrentComponent();\r\n  const unsubs = [];\r\n  for (const dep of deps) {\r\n    const subscribe = typeof dep === \"function\" ? dep : dep?.subscribe;\r\n    if (typeof subscribe === \"function\") {\r\n      const u = subscribe(() => { evaluate(); if (comp) comp.update(); });\r\n      unsubs.push(u);\r\n    }\r\n  }\r\n  if (comp) comp.onUnmount(() => { unsubs.forEach(u => u && u()); subs.clear(); });\r\n\r\n  return {\r\n    get value() { return cached; },\r\n    subscribe(fn) { subs.add(fn); fn(cached); return () => subs.delete(fn); },\r\n    recompute: evaluate,\r\n  };\r\n}\r\n\r\n\r\n", "// useFetch.js\r\nimport { useCurrentComponent } from \"../reactive-core.js\";\r\nimport { createState } from \"../compose/context.js\";\r\n\r\nexport function useFetch(url, options = {}) {\r\n  const comp = useCurrentComponent();\r\n  const state = createState({ data: null, loading: true, error: null });\r\n\r\n  async function run() {\r\n    state.setState(s => ({ ...s, loading: true }));\r\n\r\n    try {\r\n      const res = await fetch(url, options);\r\n      const data = await res.json();\r\n      state.setState({ data, error: null, loading: false });\r\n      comp?.emit(\"fetch::done\", { url, data });\r\n    } catch (error) {\r\n      state.setState({ data: null, error, loading: false });\r\n      comp?.emit(\"fetch::error\", { url, error });\r\n    }\r\n  }\r\n\r\n  if (comp) {\r\n    comp.onMount(run);\r\n    comp.onEmit(\"fetch::refresh\", run);\r\n  }\r\n  return { get: state.get, subscribe: state.subscribe, refresh: run };\r\n}\r\n"],
  "mappings": "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",
  "names": ["createChannelMap", "channels", "eventName", "fn", "set", "payload", "createState", "initial", "state", "subs", "setState", "next", "subscribe", "get", "context", "stores", "shared", "key", "api", "event", "currentComponent", "useCurrentComponent", "currentComponent", "useState", "initial", "state", "createState", "get", "set", "next", "comp", "useCurrentComponent", "unsub", "shared", "key", "store", "useFetch", "url", "options", "comp", "useCurrentComponent", "state", "createState", "run", "data", "error"]
}
